<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【LeetCode】删除有序数组中的重复项Day3</title>
      <link href="/2024/03/07/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9Day3/"/>
      <url>/2024/03/07/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9Day3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】删除有序数组中的重复项Day3"><a href="#【LeetCode】删除有序数组中的重复项Day3" class="headerlink" title="【LeetCode】删除有序数组中的重复项Day3"></a>【LeetCode】删除有序数组中的重复项Day3</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><h2 id="1-三指针"><a href="#1-三指针" class="headerlink" title="1. 三指针"></a>1. 三指针</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    第一个指针用来指向存放元素位置并计算唯一元素的数量k。剩下两个指针（左右指针）用来判断重复出现的元素。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    若左指针指向的元素等于右指针，使右指针右移一位，直到左指针不等于右指针，将左指针的元素赋给第一个指针指向的位置，第一个指针右移一位，右指针右移一位，左指针移到右指针左一位，每次循环都要判断右指针是否最后一位，若是，则直接将右指针指向的元素赋给第一个指针指向的位置。</p><p>​    当右指针大于等于数组大小的时候，右指针遍历完数组中的所有元素。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] != nums[right])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[p] = nums[left];</span><br><span class="line">            p++;</span><br><span class="line">            left = right;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] == nums[right])&#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == numsSize)&#123;</span><br><span class="line">            nums[p] = nums[numsSize<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>方法一：双指针</p><p>这道题目的要求是：对给定的有序数组 <em>nums</em> 删除重复元素，在删除重复元素之后，每个元素只出现一次，并返回新的长度，上述操作必须通过原地修改数组的方法，使用 <em>O(1)</em> 的空间复杂度完成。</p><p>由于给定的数组 <em>nums</em> 是有序的，因此对于任意 <em>i&lt;j</em>，如果 <em>nums[i]=nums[j]</em>，则对任意 <em>i≤k≤j</em>，必有 <em>nums[i]=nums[k]=nums[j]</em>，即相等的元素在数组中的下标一定是连续的。利用数组有序的特点，可以通过双指针的方法删除重复元素。</p><p>如果数组 <em>nums</em> 的长度为 0，则数组不包含任何元素，因此返回 0。</p><p>当数组 <em>nums</em> 的长度大于 0 时，数组中至少包含一个元素，在删除重复元素之后也至少剩下一个元素，因此 <em>nums[0]</em> 保持原状即可，从下标 111 开始删除重复元素。</p><p>定义两个指针 <em>fast</em> 和 <em>slow</em> 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 <em>1</em>。</p><p>假设数组 <em>nums</em> 的长度为 <em>n</em>。将快指针 <em>fast</em> 依次遍历从 <em>1</em> 到 <em>n−1</em> 的每个位置，对于每个位置，如果 <em>nums[fast]≠nums[fast−1]</em>，说明 <em>nums[fast]</em> 和之前的元素都不同，因此将 <em>nums[fast]</em> 的值复制到 <em>nums[slow]</em>，然后将 <em>slow</em>的值加 <em>1</em>，即指向下一个位置。</p><p>遍历结束之后，从 <em>nums[0]</em> 到 <em>nums[slow−1]</em> 的每个元素都不相同且包含原数组中的每个不同的元素，因此新的长度即为 <em>slow</em>，返回 <em>slow</em> 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fast = <span class="number">1</span>, slow = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; numsSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            ++slow;</span><br><span class="line">        &#125;</span><br><span class="line">        ++fast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    自己的方法有点多此一举了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】移除元素Day2</title>
      <link href="/2024/03/07/LeetCode/%E3%80%90LeetCode%E3%80%91%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0Day2/"/>
      <url>/2024/03/07/LeetCode/%E3%80%90LeetCode%E3%80%91%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0Day2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】移除元素Day2"><a href="#【LeetCode】移除元素Day2" class="headerlink" title="【LeetCode】移除元素Day2"></a>【LeetCode】移除元素Day2</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/原地算法">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素</p><h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    因为元素顺序可以改变并且不需要考虑数组中超出新长度后面的元素，所以可以从数组首尾向中间遍历。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    如果左指针指向的元素等于val，将右指针指向的元素复制到左指针的位置，然后右指针左移一位。若复制过来的元素也等于val，继续把右指针指向的元素复制过来，直到左指针指向的元素不等于val。</p><p>​    当左指针和右指针重合的时候，左右指针遍历完数组中所有元素。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">            nums[left] = nums[right - <span class="number">1</span>];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】第一个驱动</title>
      <link href="/2023/10/15/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/10/15/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】第一个驱动"><a href="#【嵌入式】第一个驱动" class="headerlink" title="【嵌入式】第一个驱动"></a>【嵌入式】第一个驱动</h1><h2 id="编写驱动程序步骤"><a href="#编写驱动程序步骤" class="headerlink" title="编写驱动程序步骤"></a>编写驱动程序步骤</h2><ol><li>确定主设备号，也可以让内核分配</li><li>定义驱动程序的file_operations结构体</li><li>实现驱动程序对应的drv_open/drv_read/drv_write等函数，填入file_operations结构体</li><li>创建入口函数来安装驱动程序，把file_operations结构体告诉内核，调用<code>register_chrdev</code></li><li>创建出口函数来卸载驱动程序，出口函数调用<code>unregister_chrdev</code></li><li>其他完善，入口函数：提供设备信息<code>class_create</code>，自动创建设备节点<code>device_create</code>；出口函数：<code>class_destroy</code>，<code>device_destroy</code></li></ol><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><div class="tip bell"><p>代码可参考内核源码中driver/char的程序，包含头文件，写框架，传输数据</p></div><ul><li><p>驱动中实现open，read，write，releas，APP调用这些函数时，都打印内核信息</p></li><li><p>APP调用write函数时，传入的数据保存在驱动中</p></li><li><p>APP调用read函数时，把驱动中保存的数据返回给APP</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 确定主设备号 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;<span class="comment">//令major=0，让内核给驱动设置设备号</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kernel_buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b)(a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动对应的open/read/write等函数，填入file_operations结构体 */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<span class="comment">//打印内核信息，下同</span></span><br><span class="line">err = copy_to_user(buf, kernel_buf, MIN(size, <span class="number">1024</span>));<span class="comment">//copy_to_user(void __user *to, const void *from, unsigned long n)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello_drv_read error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> MIN(size, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">err = copy_from_user(kernel_buf, buf, MIN(size, <span class="number">1024</span>));<span class="comment">//copy_from_user(void *to, const void __user *from, unsigned long n)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello_drv_write error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> MIN(size, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义自己的file_operations结构体 */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.open= hello_drv_open,</span><br><span class="line">.read= hello_drv_read,</span><br><span class="line">.write      = hello_drv_write,</span><br><span class="line">.release    = hello_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把file_operations结构体告诉内核：注册驱动程序 */</span></span><br><span class="line"><span class="comment">/* 注册驱动程序,入口函数：安装驱动程序时，就会去调用这个入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv);  <span class="comment">/* /dev/hello */</span></span><br><span class="line"></span><br><span class="line">hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br><span class="line">err = PTR_ERR(hello_class);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(hello_class)) &#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">/* /dev/hello */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出口函数：卸载驱动程序时，就会去调用这个出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">device_destroy(hello_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">class_destroy(hello_class);</span><br><span class="line">unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他完善：提供设备信息，自动创建设备节点 */</span></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】文件IO基础</title>
      <link href="/2023/08/13/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%96%87%E4%BB%B6IO/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E6%96%87%E4%BB%B6IO/"/>
      <url>/2023/08/13/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%96%87%E4%BB%B6IO/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E6%96%87%E4%BB%B6IO/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】文件IO基础"><a href="#【嵌入式】文件IO基础" class="headerlink" title="【嵌入式】文件IO基础"></a>【嵌入式】文件IO基础</h1><p>​    在Linux系统中，一切都是文件：普通文件、驱动程序、网络通信等等。所有的操作，都是通过文件IO来操作的。</p><pre><code>## 通用的IO模型：创建/打开/读写/定位/关闭</code></pre><ol><li><p>创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>参数mode指定新建文件的存取权限，它同umask一起决定文件的最终权限(mode&amp;umask)，其中，umask代表了文件在创建时需要去掉的一些存取权限。umask可通过系统调用umask()来改变：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">umask</span><span class="params">(<span class="type">int</span> newmask)</span>;</span><br></pre></td></tr></table></figure><p>该调用将umask设置为newmask，然后返回旧的umask，它只影响读、写和执行权限。</p></li><li><p>打开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>open()函数有两种形式，其中pathname是我们要打开的文件名(包含路径名称，缺省是认为在当前路径下面)，flags可以是下表的一个或几个值的组合。</p><p>|   标志    |                        含义                         |<br>| :———-: | :————————————————————————-: |<br>| O_RDONLY  |                以只读的方式打开文件                 |<br>| O_WRONLY  |                以只写的方式打开文件                 |<br>|  O_RDWR   |                以读写的方式打开文件                 |<br>| O_APPEND  |                以追加的方式打开文件                 |<br>|  O_CREAT  |                    创建一个文件                     |<br>|  O_EXEC   | 如果使用了O_CREAT而且文件已经存在，就会发生一个错误 |<br>| O_NOBLOCK |             以非阻塞的方式打开一个文件              |<br>|  O_TRUNC  |         如果文件已经存在，则删除文件的内容          |</p><p>O_RDONLY、O_WRONLY、O_RDWR三个标志只能使用任意一个。</p><p>如果使用了O_CREAT标志，则需要指定mode标志，以表示文件的访问权限。</p></li><li><p>读写</p></li><li><p>定位</p></li><li><p>关闭</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】开发板挂载Ubuntu的NFS目录</title>
      <link href="/2023/06/03/%E5%B5%8C%E5%85%A5%E5%BC%8F/NFS/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E5%BC%80%E5%8F%91%E6%9D%BF%E6%8C%82%E8%BD%BDUbuntu%E7%9A%84NFS%E7%9B%AE%E5%BD%95/"/>
      <url>/2023/06/03/%E5%B5%8C%E5%85%A5%E5%BC%8F/NFS/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E5%BC%80%E5%8F%91%E6%9D%BF%E6%8C%82%E8%BD%BDUbuntu%E7%9A%84NFS%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】开发板挂载Ubuntu的NFS目录"><a href="#【嵌入式】开发板挂载Ubuntu的NFS目录" class="headerlink" title="【嵌入式】开发板挂载Ubuntu的NFS目录"></a>【嵌入式】开发板挂载Ubuntu的NFS目录</h1><div class="tip "><p>NFS协议</p></div><p>​    NFS实现了一个跨越网络的文件访问功能，如下图可以简要说明其原理。其整个架构为Client-Server架构，客户端和服务端通过RPC协议进行通信，RPC协议可以简单的理解为一个基于TCP的应用层协议，它简化命令和数据的传输。NFS最大的特点是将服务端的文件系统目录树映射到客户端，而在客户端访问该目录树与访问本地文件系统没有任何差别，客户端并不知道这个文件系统目录树是本地的还是远在另外一台服务器。</p><div class="tip "><p>挂载ubuntu的nfs目录的意义</p></div><p>​    有些时候需要多次调试开发板文件系统内的某个应用程序，这就需要多次进行编译拷贝等操作，所以在前期进行调试时可以直接让开发板使用ubuntu的nfs目录下文件系统来进行远程调试，用以提高调试效率，加快研发速度。</p><h2 id="使用网络文件系统（NFS）的前提"><a href="#使用网络文件系统（NFS）的前提" class="headerlink" title="使用网络文件系统（NFS）的前提"></a>使用网络文件系统（NFS）的前提</h2><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><div class="tip info"><p>cat /etc/exports</p></div><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202401182049704.png" alt="fig1"></p><p>/home/book/ 目录可给任何用户使用。</p><h3 id="启动NFS"><a href="#启动NFS" class="headerlink" title="启动NFS"></a>启动NFS</h3><p>查看NFS是否启动</p><div class="tip info"><p>ps -A | grep nfs</p></div><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202401182049491.png" alt="fig2"></p><p>如上图即可。</p><div class="tip bell"><p>权限和NFS的配置，在环境配置中执行的脚本已经自动打开</p></div><h3 id="挂载（mount）"><a href="#挂载（mount）" class="headerlink" title="挂载（mount）"></a>挂载（mount）</h3><h4 id="开发板与ubuntu是否互ping成功"><a href="#开发板与ubuntu是否互ping成功" class="headerlink" title="开发板与ubuntu是否互ping成功"></a>开发板与ubuntu是否互ping成功</h4><div class="tip info"><p>查看ip：ifconfig</p></div><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202401182050473.png" alt="fig3"></p><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202401182049833.png" alt="fig4"></p><p>查看完ip后，两机互ping。</p><div class="tip key"><p>开发板挂载：mount -t nfs -o nolock,vers=3 192.168.5.11:/home/book/nfs_rootfs /mnt</p></div><p>挂载完成后，可在nfs_rootfs文件夹中添加文件测试。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】Makefile 基础</title>
      <link href="/2023/05/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/Makefile/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91Makefile/"/>
      <url>/2023/05/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/Makefile/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91Makefile/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】Makefile-基础"><a href="#【嵌入式】Makefile-基础" class="headerlink" title="【嵌入式】Makefile 基础"></a>【嵌入式】Makefile 基础</h1><h2 id="1-Makefile-是什么"><a href="#1-Makefile-是什么" class="headerlink" title="1. Makefile 是什么"></a>1. Makefile 是什么</h2><p>​    一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile就像一个Shell脚本一样，也可以执行操作系统的命令。</p><div class="tip sync"><p>Makefile 可以大大提高编译效率，在修改源文件或头文件时，只需要重新编译涉及到的文件，</p></div><h2 id="2-Makefile-规则"><a href="#2-Makefile-规则" class="headerlink" title="2. Makefile 规则"></a>2. Makefile 规则</h2><p>​    一个Makefile文件包含一系列的规则，其样式如下：</p><div class="tip info"><p>目标(target)…: 依赖(dependency)…</p><p><tab> 命令(command)</p></div><p>​    如果“依赖文件”比“目标文件”更加新，就执行命令来重新生成“目标文件”。</p><p>​    命令被执行的两个条件：1. “依赖文件”比“目标文件”新；2. 目标文件未生成。</p><h2 id="3-Makefile-语法"><a href="#3-Makefile-语法" class="headerlink" title="3. Makefile 语法"></a>3. Makefile 语法</h2><ul><li><p>make命令</p><p>​        执行make命令时，会在当前目录下查找“Makefile”文件，并根据它的指示去执行操作，生成第一个目标。</p><p>​        使用“-f”选项指定文件，不再使用名为“Makefile”的文件，比如：</p><div class="tip info"><p>make    -f    Makefile.build</p></div><p>​        使用“-C”选项指定目录，切换到其他目录里去，比如：</p><div class="tip info"><p>make    -C    a/    -f    Makefile.build</p></div><p>​        指定目标，不再默认生成第一个目标：</p><div class="tip info"><p>make    -C    a/    -f    Makefile.build    other_target</p></div></li><li><p>变量</p><p>变量定义：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A =  xxx// 延时变量</span><br><span class="line"></span><br><span class="line">B ?= xxx// 延时变量，只有第一次定义时赋值才成功</span><br><span class="line"></span><br><span class="line">C :=  xxx// 立即变量</span><br><span class="line"></span><br><span class="line">D += xxx// D之前是什么变量就是什么变量</span><br></pre></td></tr></table></figure><p>​        编译程序时，切换到其他目录执行Makefile，如果想让某个变量的值在所有目录都可见，可以使用export，如：</p><div class="tip info"><p>CC = $(CROSS_COMPILE)gcc </p><p>  export CC = $(CROSS_COMPILE)gcc </p></div></li><li><p>shell命令</p><div class="tip info"><p>TOPDIR := $(shell pwd)</p></div><p>​        TOPDIR为立即变量，值为shell命令pwd的结果。</p></li><li><p>第一个目标</p><p>​        执行make命令若不指定目标，默认生成第一个目标。</p><p>​        所以第一个目标，位置很重要。有时候不太方便把第一个目标完整地放<br>在文件前面，这时可以在文件的前面直接放置目标，在后面再完善它的依赖与<br>命令。比如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">First_target: // 这句话放在前面</span></span><br><span class="line">...... // 其他代码，比如 <span class="keyword">include</span> 其他文件得到后面的 xxx 变量</span><br><span class="line">First_target : <span class="variable">$(xxx)</span> <span class="variable">$(yyy)</span> // 在文件的后面再来完善</span><br><span class="line">command</span><br></pre></td></tr></table></figure></li><li><p>假想目标</p><p>​        假如Makefile中有这样的目标：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">rm -f <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>​        如果当前目录下恰好有名为“clean”的文件，那么执行“make clean”时它就不会执行删除命令。这时可以将clean设置为假想目标，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">rm -f <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>常用函数</li></ul><ol><li><p>$(foreach var,list,text)</p><p>简单地说，就是 for each var in list, change it to text。对 list 中的每一个元素，取出来赋给 var，然后把 var 改为 text 所描述的形式。</p><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objs := a.o b.o</span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f, <span class="variable">$(objs)</span>, .<span class="variable">$(f)</span>.d)</span> // 最终 dep_files := .a.o.d .b.o.d</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>$(wildcard pattern)</p><p>pattern 所列出的文件是否存在，把存在的文件都列出来。<br>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src_files := $( wildcard *.c) // 最终 src_files 中列出了当前目录下的所有.c 文件</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>$(filter pattern…,text)</p><p>把 text 中符合 pattern 格式的内容，filter(过滤)出来、留下来。</p><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-y := a.o b.o c/ d/</span><br><span class="line">DIR := <span class="variable">$(<span class="built_in">filter</span> %/, $(obj-y)</span>) //结果为：c/ d/</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>$(filter-out pattern…,text)</p><p>把 text 中符合 pattern 格式的内容，filter-out(过滤)出来、扔掉。</p><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-y := a.o b.o c/ d/</span><br><span class="line">DIR := <span class="variable">$(<span class="built_in">filter</span>-out %/, $(obj-y)</span>) //结果为：a.o b.o</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>$(patsubst pattern,replacement,text)</p><p>寻找”text”中符合格式”pattern”的字，用”replacement”替换它们。</p><p>“pattern”和”replacement”中可以使用通配符。</p><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subdir-y := c/ d/</span><br><span class="line">subdir-y := <span class="variable">$(<span class="built_in">patsubst</span> %/, %, $(subdir-y)</span>) // 结果为：c d</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】虚拟机Ubuntu环境配置</title>
      <link href="/2023/05/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/05/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】虚拟机Ubuntu环境配置"><a href="#【嵌入式】虚拟机Ubuntu环境配置" class="headerlink" title="【嵌入式】虚拟机Ubuntu环境配置"></a>【嵌入式】虚拟机Ubuntu环境配置</h1><h2 id="一键配置开发环境（此脚本只支持Ubuntu-16-04-Ubuntu-18-04）"><a href="#一键配置开发环境（此脚本只支持Ubuntu-16-04-Ubuntu-18-04）" class="headerlink" title="一键配置开发环境（此脚本只支持Ubuntu-16.04/Ubuntu-18.04）"></a>一键配置开发环境（此脚本只支持Ubuntu-16.04/Ubuntu-18.04）</h2><h3 id="在终端输入下面命令"><a href="#在终端输入下面命令" class="headerlink" title="在终端输入下面命令"></a>在终端输入下面命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://e.coding.net/weidongshan/DevelopmentEnvConf.git</span><br><span class="line"></span><br><span class="line">cd DevelopmentEnvConf</span><br><span class="line"></span><br><span class="line">sudo ./Configuring_ubuntu.sh</span><br></pre></td></tr></table></figure><h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><div class="tip error"><p>E: Problem executing scripts APT::Update::Post-Invoke-Success ‘if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli; then appstreamcli refresh &gt; /dev/null; fi’<br>E: Sub-process returned an error code</p></div><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><div class="tip success"><p>sudo apt upgrade</p></div>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
