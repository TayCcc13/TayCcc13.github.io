<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【LeetCode】买卖股票的最佳时机Day6</title>
      <link href="/2024/03/21/LeetCode/%E3%80%90LeetCode%E3%80%91%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BADay6/"/>
      <url>/2024/03/21/LeetCode/%E3%80%90LeetCode%E3%80%91%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BADay6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】买卖股票的最佳时机Day6"><a href="#【LeetCode】买卖股票的最佳时机Day6" class="headerlink" title="【LeetCode】买卖股票的最佳时机Day6"></a>【LeetCode】买卖股票的最佳时机Day6</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p></li></ul><h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    依次遍历数组相邻两个数先找到极小值，然后一直寻找极大值，计算其利润并比较大小。若找到新的极小值先与旧的极小值比较，若新极小值小于旧极小值，则将新极小值替代旧极小值并将极大值置0，否则不变，循环上述步骤。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算股票的最大利润</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param prices 股票价格数组</span></span><br><span class="line"><span class="comment"> * @param pricesSize 股票价格数组的大小</span></span><br><span class="line"><span class="comment"> * @return 返回最大利润</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> minPrices = prices[<span class="number">0</span>]; <span class="comment">// 初始化最小价格为第一天的价格</span></span><br><span class="line">    <span class="type">int</span> maxPrices = <span class="number">0</span>; <span class="comment">// 初始化最大价格为0</span></span><br><span class="line">    <span class="type">int</span> maxProfit = <span class="number">0</span>; <span class="comment">// 初始化最大利润为0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left;</span><br><span class="line">    <span class="type">int</span> right;</span><br><span class="line">    <span class="type">int</span> g;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pricesSize == <span class="number">1</span>)&#123; <span class="comment">// 如果只有一天的价格，无法交易，直接返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        left = <span class="number">0</span>; <span class="comment">// 设置左指针为数组的第一个元素</span></span><br><span class="line">        right = <span class="number">1</span>; <span class="comment">// 设置右指针为数组的第二个元素</span></span><br><span class="line">        g = prices[left]&gt;prices[right] ? <span class="number">0</span> : <span class="number">1</span>; <span class="comment">// 判断价格趋势，g为0表示递减，g为1表示递增</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历价格数组</span></span><br><span class="line">    <span class="keyword">while</span>(right&lt;pricesSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果价格递减并且g为1，表示进入递减阶段</span></span><br><span class="line">        <span class="keyword">if</span>(prices[left] &gt; prices[right] &amp;&amp; g)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[left] &gt; maxPrices)&#123; <span class="comment">// 更新最大价格</span></span><br><span class="line">                maxPrices = prices[left];</span><br><span class="line">                <span class="keyword">if</span>(maxProfit &lt; maxPrices - minPrices)&#123; <span class="comment">// 更新最大利润</span></span><br><span class="line">                    maxProfit = maxPrices - minPrices;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            g = <span class="number">0</span>; <span class="comment">// 标记为递减</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果价格递增并且g为0，表示进入递增阶段</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(prices[left] &lt; prices[right] &amp;&amp; !g)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[left] &lt; minPrices)&#123; <span class="comment">// 更新最小价格</span></span><br><span class="line">                minPrices = prices[left];</span><br><span class="line">                maxPrices = <span class="number">0</span>; <span class="comment">// 重置最大价格</span></span><br><span class="line">            &#125;</span><br><span class="line">            g = <span class="number">1</span>; <span class="comment">// 标记为递增</span></span><br><span class="line">        &#125;</span><br><span class="line">        left++; <span class="comment">// 移动左指针</span></span><br><span class="line">        right++; <span class="comment">// 移动右指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理最后一个价格</span></span><br><span class="line">    <span class="keyword">if</span>(!g &amp;&amp; prices[pricesSize<span class="number">-1</span>]&lt;minPrices)&#123;</span><br><span class="line">        minPrices = prices[pricesSize<span class="number">-1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(g &amp;&amp; prices[pricesSize<span class="number">-1</span>]&gt;maxPrices)&#123;</span><br><span class="line">        maxPrices = prices[pricesSize<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(maxProfit &lt; maxPrices - minPrices)&#123;</span><br><span class="line">             maxProfit = maxPrices - minPrices;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果最大利润小于等于0，则返回0</span></span><br><span class="line">    <span class="keyword">if</span>(maxProfit &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit; <span class="comment">// 返回最大利润</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode官方题解"><a href="#LeetCode官方题解" class="headerlink" title="LeetCode官方题解"></a>LeetCode官方题解</h3><h4 id="方法一：一次遍历"><a href="#方法一：一次遍历" class="headerlink" title="方法一：一次遍历"></a>方法一：一次遍历</h4><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/136684/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/136684/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/</a><br>来源：力扣（LeetCode）</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">        <span class="type">int</span> minprice = inf, maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price: prices) &#123;</span><br><span class="line">            maxprofit = <span class="built_in">max</span>(maxprofit, price - minprice);</span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】多数元素Day5</title>
      <link href="/2024/03/13/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0Day5/"/>
      <url>/2024/03/13/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0Day5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】多数元素Day5"><a href="#【LeetCode】多数元素Day5" class="headerlink" title="【LeetCode】多数元素Day5"></a>【LeetCode】多数元素Day5</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p></li></ul><h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    依次遍历数组中的每个数并统计出现的次数，并针对特殊情况作出优化。</p><p>​    （受限于知识储备，之前题目的影响，本题没想出很好的方法，自己的方法在特殊情况的时候应该还会超时。）</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    使用双指针遍历数组元素，并统计出现次数，直到出现次数大于<code>⌊ n/2 ⌋</code>，返回当前统计的元素 ；或出现次数加上剩余元素小于<code>⌊ n/2 ⌋</code> ，进行下一个元素的统计，直到有元素出现次数大于<code>⌊ n/2 ⌋</code>。具体方法与前面删除重复项相似。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="type">int</span> fast, slow;</span><br><span class="line"><span class="type">int</span> mark = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fast = <span class="number">1</span>;</span><br><span class="line">slow = <span class="number">0</span>;</span><br><span class="line">res = numsSize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(mark &lt;= (numsSize/<span class="number">2</span>))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[slow] == nums[fast])</span><br><span class="line">        &#123;</span><br><span class="line">            mark++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast++; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fast--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res--;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mark &gt; (numsSize/<span class="number">2</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[slow];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((mark+res) &lt;= (numsSize/<span class="number">2</span>) &amp;&amp; (i == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            slow = numsSize - slow;</span><br><span class="line">            fast = slow - <span class="number">1</span>;</span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            res = fast;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((mark+res) &lt;= (numsSize/<span class="number">2</span>) &amp;&amp; (i == <span class="number">1</span>))&#123;</span><br><span class="line">            slow = numsSize - slow;</span><br><span class="line">            fast = slow + <span class="number">1</span>;</span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            res = numsSize - fast;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[slow+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode官方题解"><a href="#LeetCode官方题解" class="headerlink" title="LeetCode官方题解"></a>LeetCode官方题解</h3><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/">https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/</a><br>来源：力扣（LeetCode）</p><h4 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h4><h5 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h5><p>​    我们知道出现次数最多的元素大于 n/2 次，所以可以用哈希表来快速统计每个元素出现的次数。</p><p>​    我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。</p><p>​    我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，返回值最大的键。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">        <span class="type">int</span> majority = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            ++counts[num];</span><br><span class="line">            <span class="keyword">if</span> (counts[num] &gt; cnt) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                cnt = counts[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h4><p>思路及算法</p><p>​    如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 n/2 的元素（下标从 0 开始）一定是众数。</p><p>​    对于这种算法，我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 nnn 为奇数的情况，第二个例子是 n 为偶数的情况。</p><p>​    对于每种情况，数组上面的线表示如果众数是数组中的最小值时覆盖的下标，数组下面的线表示如果众数是数组中的最大值时覆盖的下标。对于其他的情况，这条线会在这两种极端情况的中间。对于这两种极端情况，它们会在下标为 n/2 的地方有重叠。因此，无论众数是多少，返回 n/2 下标对应的值都是正确的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法三：Boyer-Moore-投票算法"><a href="#方法三：Boyer-Moore-投票算法" class="headerlink" title="方法三：Boyer-Moore 投票算法"></a>方法三：Boyer-Moore 投票算法</h4><p>思路</p><p>​    如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</p><p>​    首先给出 Boyer-Moore 算法的详细步骤：</p><p>​    我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</p><p>​    我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：</p><p>​    如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</p><p>​    如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</p><p>​    在遍历完成后，candidate 即为整个数组的众数。</p><p>​    我们举一个具体的例子，例如下面的这个数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span><br></pre></td></tr></table></figure><p>​    在遍历到数组中的第一个元素以及每个在 | 之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。</p><p>​    Boyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考：</p><p>​    首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。</p><p>​    那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span><br></pre></td></tr></table></figure><p>​    作为例子，首先写下它在每一步遍历时 candidate 和 count 的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span><br><span class="line">candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7</span><br><span class="line">count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4</span><br></pre></td></tr></table></figure><p>​    我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span><br><span class="line">value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4</span><br></pre></td></tr></table></figure><p>​    有没有发现什么？我们将 count 和 value 放在一起：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span><br><span class="line">count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4</span><br><span class="line">value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4</span><br></pre></td></tr></table></figure><p>​    发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！</p><p>​    为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。</p><p>​    这样以来，由于：</p><p>​    我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此；</p><p>​    由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数；</p><p>​    在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数 maj。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> candidate = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == candidate)</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (--count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    学到了哈希表的使用和Boyer-Moore投票算法。方法二的排序思路也想到了，但差一点。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】删除有序数组中的重复项ⅡDay4</title>
      <link href="/2024/03/08/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E2%85%A1Day4/"/>
      <url>/2024/03/08/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E2%85%A1Day4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】删除有序数组中的重复项ⅡDay4"><a href="#【LeetCode】删除有序数组中的重复项ⅡDay4" class="headerlink" title="【LeetCode】删除有序数组中的重复项ⅡDay4"></a>【LeetCode】删除有序数组中的重复项ⅡDay4</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><p>给你一个有序数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p></li></ul><h2 id="1-三指针"><a href="#1-三指针" class="headerlink" title="1. 三指针"></a>1. 三指针</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    第一个指针p用来指向存放元素位置并计算唯一元素的数量k。剩下两个指针（左右指针）用来判断重复出现的元素，增加了一个标记位mark，记录元素出现次数。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    若左指针指向的元素等于右指针，使右指针右移一位，mark加一，直到左指针不等于右指针，将左指针的元素赋给第一个指针p指向的位置，mark置一，第一个指针p右移一位，右指针右移一位，左指针移到右指针左一位，每次循环都要判断右指针是否最后一位，若是，则直接将右指针指向的元素赋给第一个指针p指向的位置。（每次赋值前需判断mark是否大于等于2，若是，则需将nums[p]和nums[p+1]都赋值）</p><p>​    当右指针大于等于数组大小的时候，右指针遍历完数组中的所有元素。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] != nums[right])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mark &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[p++] = nums[left];</span><br><span class="line">                nums[p++] = nums[left];   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[p++] = nums[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left = right;</span><br><span class="line">            right++;</span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] == nums[right])&#123;</span><br><span class="line">            right++;</span><br><span class="line">            mark++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == numsSize)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mark &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[p++] = nums[left];</span><br><span class="line">                nums[p] = nums[left];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[p] = nums[numsSize<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode官方题解"><a href="#LeetCode官方题解" class="headerlink" title="LeetCode官方题解"></a>LeetCode官方题解</h3><h4 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h4><h5 id="思路及解法"><a href="#思路及解法" class="headerlink" title="思路及解法"></a>思路及解法</h5><p>​    因为给定数组是有序的，所以相同元素必然连续。我们可以使用双指针解决本题，遍历数组检查每一个元素是否应该被保留，如果应该被保留，就将其移动到指定位置。具体地，我们定义两个指针 <em>slow</em> 和 fast 分别为慢指针和快指针，其中慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度，即 <em>nums[fast]</em> 表示待检查的第一个元素，<em>nums[slow−1]</em>为上一个应该被保留的元素所移动到的指定位置。</p><p>​    因为本题要求相同元素最多出现两次而非一次，所以我们需要检查上上个应该被保留的元素 <em>nums[slow−2]</em> 是否和当前待检查元素 <em>nums[fast]</em> 相同。当且仅当 <em>nums[slow−2]=nums[fast]</em> 时，当前待检查元素 <em>nums[fast]</em>不应该被保留（因为此时必然有<em>nums[slow−2]=nums[slow−1]=nums[fast]</em>）。最后，slow 即为处理好的数组的长度。</p><p>​    特别地，数组的前两个数必然可以被保留，因此对于长度不超过 2 的数组，我们无需进行任何处理，对于长度超过 2 的数组，我们直接将双指针的初始值设为 2 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> slow = <span class="number">2</span>, fast = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; numsSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[slow - <span class="number">2</span>] != nums[fast]) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            ++slow;</span><br><span class="line">        &#125;</span><br><span class="line">        ++fast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>​    还是跟昨天一样的问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】删除有序数组中的重复项Day3</title>
      <link href="/2024/03/08/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9Day3/"/>
      <url>/2024/03/08/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9Day3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】删除有序数组中的重复项Day3"><a href="#【LeetCode】删除有序数组中的重复项Day3" class="headerlink" title="【LeetCode】删除有序数组中的重复项Day3"></a>【LeetCode】删除有序数组中的重复项Day3</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><h2 id="1-三指针"><a href="#1-三指针" class="headerlink" title="1. 三指针"></a>1. 三指针</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    第一个指针用来指向存放元素位置并计算唯一元素的数量k。剩下两个指针（左右指针）用来判断重复出现的元素。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    若左指针指向的元素等于右指针，使右指针右移一位，直到左指针不等于右指针，将左指针的元素赋给第一个指针指向的位置，第一个指针右移一位，右指针右移一位，左指针移到右指针左一位，每次循环都要判断右指针是否最后一位，若是，则直接将右指针指向的元素赋给第一个指针指向的位置。</p><p>​    当右指针大于等于数组大小的时候，右指针遍历完数组中的所有元素。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] != nums[right])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[p] = nums[left];</span><br><span class="line">            p++;</span><br><span class="line">            left = right;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] == nums[right])&#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == numsSize)&#123;</span><br><span class="line">            nums[p] = nums[numsSize<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>方法一：双指针</p><p>这道题目的要求是：对给定的有序数组 <em>nums</em> 删除重复元素，在删除重复元素之后，每个元素只出现一次，并返回新的长度，上述操作必须通过原地修改数组的方法，使用 <em>O(1)</em> 的空间复杂度完成。</p><p>由于给定的数组 <em>nums</em> 是有序的，因此对于任意 <em>i&lt;j</em>，如果 <em>nums[i]=nums[j]</em>，则对任意 <em>i≤k≤j</em>，必有 <em>nums[i]=nums[k]=nums[j]</em>，即相等的元素在数组中的下标一定是连续的。利用数组有序的特点，可以通过双指针的方法删除重复元素。</p><p>如果数组 <em>nums</em> 的长度为 0，则数组不包含任何元素，因此返回 0。</p><p>当数组 <em>nums</em> 的长度大于 0 时，数组中至少包含一个元素，在删除重复元素之后也至少剩下一个元素，因此 <em>nums[0]</em> 保持原状即可，从下标 111 开始删除重复元素。</p><p>定义两个指针 <em>fast</em> 和 <em>slow</em> 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 <em>1</em>。</p><p>假设数组 <em>nums</em> 的长度为 <em>n</em>。将快指针 <em>fast</em> 依次遍历从 <em>1</em> 到 <em>n−1</em> 的每个位置，对于每个位置，如果 <em>nums[fast]≠nums[fast−1]</em>，说明 <em>nums[fast]</em> 和之前的元素都不同，因此将 <em>nums[fast]</em> 的值复制到 <em>nums[slow]</em>，然后将 <em>slow</em>的值加 <em>1</em>，即指向下一个位置。</p><p>遍历结束之后，从 <em>nums[0]</em> 到 <em>nums[slow−1]</em> 的每个元素都不相同且包含原数组中的每个不同的元素，因此新的长度即为 <em>slow</em>，返回 <em>slow</em> 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fast = <span class="number">1</span>, slow = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; numsSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            ++slow;</span><br><span class="line">        &#125;</span><br><span class="line">        ++fast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    自己的方法有点多此一举了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】移除元素Day2</title>
      <link href="/2024/03/07/LeetCode/%E3%80%90LeetCode%E3%80%91%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0Day2/"/>
      <url>/2024/03/07/LeetCode/%E3%80%90LeetCode%E3%80%91%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0Day2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】移除元素Day2"><a href="#【LeetCode】移除元素Day2" class="headerlink" title="【LeetCode】移除元素Day2"></a>【LeetCode】移除元素Day2</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/原地算法">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素</p><h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    因为元素顺序可以改变并且不需要考虑数组中超出新长度后面的元素，所以可以从数组首尾向中间遍历。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    如果左指针指向的元素等于val，将右指针指向的元素复制到左指针的位置，然后右指针左移一位。若复制过来的元素也等于val，继续把右指针指向的元素复制过来，直到左指针指向的元素不等于val。</p><p>​    当左指针和右指针重合的时候，左右指针遍历完数组中所有元素。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">            nums[left] = nums[right - <span class="number">1</span>];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】第一个驱动</title>
      <link href="/2023/10/15/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8/"/>
      <url>/2023/10/15/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】第一个驱动"><a href="#【嵌入式】第一个驱动" class="headerlink" title="【嵌入式】第一个驱动"></a>【嵌入式】第一个驱动</h1><h2 id="编写驱动程序步骤"><a href="#编写驱动程序步骤" class="headerlink" title="编写驱动程序步骤"></a>编写驱动程序步骤</h2><ol><li>确定主设备号，也可以让内核分配</li><li>定义驱动程序的file_operations结构体</li><li>实现驱动程序对应的drv_open/drv_read/drv_write等函数，填入file_operations结构体</li><li>创建入口函数来安装驱动程序，把file_operations结构体告诉内核，调用<code>register_chrdev</code></li><li>创建出口函数来卸载驱动程序，出口函数调用<code>unregister_chrdev</code></li><li>其他完善，入口函数：提供设备信息<code>class_create</code>，自动创建设备节点<code>device_create</code>；出口函数：<code>class_destroy</code>，<code>device_destroy</code></li></ol><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><div class="tip bell"><p>代码可参考内核源码中driver/char的程序，包含头文件，写框架，传输数据</p></div><ul><li><p>驱动中实现open，read，write，releas，APP调用这些函数时，都打印内核信息</p></li><li><p>APP调用write函数时，传入的数据保存在驱动中</p></li><li><p>APP调用read函数时，把驱动中保存的数据返回给APP</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 确定主设备号 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;<span class="comment">//令major=0，让内核给驱动设置设备号</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kernel_buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b)(a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动对应的open/read/write等函数，填入file_operations结构体 */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<span class="comment">//打印内核信息，下同</span></span><br><span class="line">err = copy_to_user(buf, kernel_buf, MIN(size, <span class="number">1024</span>));<span class="comment">//copy_to_user(void __user *to, const void *from, unsigned long n)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello_drv_read error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> MIN(size, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">err = copy_from_user(kernel_buf, buf, MIN(size, <span class="number">1024</span>));<span class="comment">//copy_from_user(void *to, const void __user *from, unsigned long n)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello_drv_write error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> MIN(size, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义自己的file_operations结构体 */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.open= hello_drv_open,</span><br><span class="line">.read= hello_drv_read,</span><br><span class="line">.write      = hello_drv_write,</span><br><span class="line">.release    = hello_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把file_operations结构体告诉内核：注册驱动程序 */</span></span><br><span class="line"><span class="comment">/* 注册驱动程序,入口函数：安装驱动程序时，就会去调用这个入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv);  <span class="comment">/* /dev/hello */</span></span><br><span class="line"></span><br><span class="line">hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br><span class="line">err = PTR_ERR(hello_class);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(hello_class)) &#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">/* /dev/hello */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出口函数：卸载驱动程序时，就会去调用这个出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">device_destroy(hello_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">class_destroy(hello_class);</span><br><span class="line">unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他完善：提供设备信息，自动创建设备节点 */</span></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】文件IO基础</title>
      <link href="/2023/08/13/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%96%87%E4%BB%B6IO/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E6%96%87%E4%BB%B6IO/"/>
      <url>/2023/08/13/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%96%87%E4%BB%B6IO/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E6%96%87%E4%BB%B6IO/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】文件IO基础"><a href="#【嵌入式】文件IO基础" class="headerlink" title="【嵌入式】文件IO基础"></a>【嵌入式】文件IO基础</h1><p>​    在Linux系统中，一切都是文件：普通文件、驱动程序、网络通信等等。所有的操作，都是通过文件IO来操作的。</p><pre><code>## 通用的IO模型：创建/打开/读写/定位/关闭</code></pre><ol><li><p>创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>参数mode指定新建文件的存取权限，它同umask一起决定文件的最终权限(mode&amp;umask)，其中，umask代表了文件在创建时需要去掉的一些存取权限。umask可通过系统调用umask()来改变：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">umask</span><span class="params">(<span class="type">int</span> newmask)</span>;</span><br></pre></td></tr></table></figure><p>该调用将umask设置为newmask，然后返回旧的umask，它只影响读、写和执行权限。</p></li><li><p>打开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>open()函数有两种形式，其中pathname是我们要打开的文件名(包含路径名称，缺省是认为在当前路径下面)，flags可以是下表的一个或几个值的组合。</p><p>|   标志    |                        含义                         |<br>| :———-: | :————————————————————————-: |<br>| O_RDONLY  |                以只读的方式打开文件                 |<br>| O_WRONLY  |                以只写的方式打开文件                 |<br>|  O_RDWR   |                以读写的方式打开文件                 |<br>| O_APPEND  |                以追加的方式打开文件                 |<br>|  O_CREAT  |                    创建一个文件                     |<br>|  O_EXEC   | 如果使用了O_CREAT而且文件已经存在，就会发生一个错误 |<br>| O_NOBLOCK |             以非阻塞的方式打开一个文件              |<br>|  O_TRUNC  |         如果文件已经存在，则删除文件的内容          |</p><p>O_RDONLY、O_WRONLY、O_RDWR三个标志只能使用任意一个。</p><p>如果使用了O_CREAT标志，则需要指定mode标志，以表示文件的访问权限。</p></li><li><p>读写</p></li><li><p>定位</p></li><li><p>关闭</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】开发板挂载Ubuntu的NFS目录</title>
      <link href="/2023/06/03/%E5%B5%8C%E5%85%A5%E5%BC%8F/NFS/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E5%BC%80%E5%8F%91%E6%9D%BF%E6%8C%82%E8%BD%BDUbuntu%E7%9A%84NFS%E7%9B%AE%E5%BD%95/"/>
      <url>/2023/06/03/%E5%B5%8C%E5%85%A5%E5%BC%8F/NFS/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E5%BC%80%E5%8F%91%E6%9D%BF%E6%8C%82%E8%BD%BDUbuntu%E7%9A%84NFS%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】开发板挂载Ubuntu的NFS目录"><a href="#【嵌入式】开发板挂载Ubuntu的NFS目录" class="headerlink" title="【嵌入式】开发板挂载Ubuntu的NFS目录"></a>【嵌入式】开发板挂载Ubuntu的NFS目录</h1><div class="tip "><p>NFS协议</p></div><p>​    NFS实现了一个跨越网络的文件访问功能，如下图可以简要说明其原理。其整个架构为Client-Server架构，客户端和服务端通过RPC协议进行通信，RPC协议可以简单的理解为一个基于TCP的应用层协议，它简化命令和数据的传输。NFS最大的特点是将服务端的文件系统目录树映射到客户端，而在客户端访问该目录树与访问本地文件系统没有任何差别，客户端并不知道这个文件系统目录树是本地的还是远在另外一台服务器。</p><div class="tip "><p>挂载ubuntu的nfs目录的意义</p></div><p>​    有些时候需要多次调试开发板文件系统内的某个应用程序，这就需要多次进行编译拷贝等操作，所以在前期进行调试时可以直接让开发板使用ubuntu的nfs目录下文件系统来进行远程调试，用以提高调试效率，加快研发速度。</p><h2 id="使用网络文件系统（NFS）的前提"><a href="#使用网络文件系统（NFS）的前提" class="headerlink" title="使用网络文件系统（NFS）的前提"></a>使用网络文件系统（NFS）的前提</h2><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><div class="tip info"><p>cat /etc/exports</p></div><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202401182049704.png" alt="fig1"></p><p>/home/book/ 目录可给任何用户使用。</p><h3 id="启动NFS"><a href="#启动NFS" class="headerlink" title="启动NFS"></a>启动NFS</h3><p>查看NFS是否启动</p><div class="tip info"><p>ps -A | grep nfs</p></div><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202401182049491.png" alt="fig2"></p><p>如上图即可。</p><div class="tip bell"><p>权限和NFS的配置，在环境配置中执行的脚本已经自动打开</p></div><h3 id="挂载（mount）"><a href="#挂载（mount）" class="headerlink" title="挂载（mount）"></a>挂载（mount）</h3><h4 id="开发板与ubuntu是否互ping成功"><a href="#开发板与ubuntu是否互ping成功" class="headerlink" title="开发板与ubuntu是否互ping成功"></a>开发板与ubuntu是否互ping成功</h4><div class="tip info"><p>查看ip：ifconfig</p></div><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202401182050473.png" alt="fig3"></p><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202401182049833.png" alt="fig4"></p><p>查看完ip后，两机互ping。</p><div class="tip key"><p>开发板挂载：mount -t nfs -o nolock,vers=3 192.168.5.11:/home/book/nfs_rootfs /mnt</p></div><p>挂载完成后，可在nfs_rootfs文件夹中添加文件测试。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】Makefile 基础</title>
      <link href="/2023/05/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/Makefile/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91Makefile/"/>
      <url>/2023/05/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/Makefile/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91Makefile/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】Makefile-基础"><a href="#【嵌入式】Makefile-基础" class="headerlink" title="【嵌入式】Makefile 基础"></a>【嵌入式】Makefile 基础</h1><h2 id="1-Makefile-是什么"><a href="#1-Makefile-是什么" class="headerlink" title="1. Makefile 是什么"></a>1. Makefile 是什么</h2><p>​    一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile就像一个Shell脚本一样，也可以执行操作系统的命令。</p><div class="tip sync"><p>Makefile 可以大大提高编译效率，在修改源文件或头文件时，只需要重新编译涉及到的文件，</p></div><h2 id="2-Makefile-规则"><a href="#2-Makefile-规则" class="headerlink" title="2. Makefile 规则"></a>2. Makefile 规则</h2><p>​    一个Makefile文件包含一系列的规则，其样式如下：</p><div class="tip info"><p>目标(target)…: 依赖(dependency)…</p><p><tab> 命令(command)</p></div><p>​    如果“依赖文件”比“目标文件”更加新，就执行命令来重新生成“目标文件”。</p><p>​    命令被执行的两个条件：1. “依赖文件”比“目标文件”新；2. 目标文件未生成。</p><h2 id="3-Makefile-语法"><a href="#3-Makefile-语法" class="headerlink" title="3. Makefile 语法"></a>3. Makefile 语法</h2><ul><li><p>make命令</p><p>​        执行make命令时，会在当前目录下查找“Makefile”文件，并根据它的指示去执行操作，生成第一个目标。</p><p>​        使用“-f”选项指定文件，不再使用名为“Makefile”的文件，比如：</p><div class="tip info"><p>make    -f    Makefile.build</p></div><p>​        使用“-C”选项指定目录，切换到其他目录里去，比如：</p><div class="tip info"><p>make    -C    a/    -f    Makefile.build</p></div><p>​        指定目标，不再默认生成第一个目标：</p><div class="tip info"><p>make    -C    a/    -f    Makefile.build    other_target</p></div></li><li><p>变量</p><p>变量定义：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A =  xxx// 延时变量</span><br><span class="line"></span><br><span class="line">B ?= xxx// 延时变量，只有第一次定义时赋值才成功</span><br><span class="line"></span><br><span class="line">C :=  xxx// 立即变量</span><br><span class="line"></span><br><span class="line">D += xxx// D之前是什么变量就是什么变量</span><br></pre></td></tr></table></figure><p>​        编译程序时，切换到其他目录执行Makefile，如果想让某个变量的值在所有目录都可见，可以使用export，如：</p><div class="tip info"><p>CC = $(CROSS_COMPILE)gcc </p><p>  export CC = $(CROSS_COMPILE)gcc </p></div></li><li><p>shell命令</p><div class="tip info"><p>TOPDIR := $(shell pwd)</p></div><p>​        TOPDIR为立即变量，值为shell命令pwd的结果。</p></li><li><p>第一个目标</p><p>​        执行make命令若不指定目标，默认生成第一个目标。</p><p>​        所以第一个目标，位置很重要。有时候不太方便把第一个目标完整地放<br>在文件前面，这时可以在文件的前面直接放置目标，在后面再完善它的依赖与<br>命令。比如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">First_target: // 这句话放在前面</span></span><br><span class="line">...... // 其他代码，比如 <span class="keyword">include</span> 其他文件得到后面的 xxx 变量</span><br><span class="line">First_target : <span class="variable">$(xxx)</span> <span class="variable">$(yyy)</span> // 在文件的后面再来完善</span><br><span class="line">command</span><br></pre></td></tr></table></figure></li><li><p>假想目标</p><p>​        假如Makefile中有这样的目标：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">rm -f <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>​        如果当前目录下恰好有名为“clean”的文件，那么执行“make clean”时它就不会执行删除命令。这时可以将clean设置为假想目标，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">rm -f <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>常用函数</li></ul><ol><li><p>$(foreach var,list,text)</p><p>简单地说，就是 for each var in list, change it to text。对 list 中的每一个元素，取出来赋给 var，然后把 var 改为 text 所描述的形式。</p><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objs := a.o b.o</span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f, <span class="variable">$(objs)</span>, .<span class="variable">$(f)</span>.d)</span> // 最终 dep_files := .a.o.d .b.o.d</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>$(wildcard pattern)</p><p>pattern 所列出的文件是否存在，把存在的文件都列出来。<br>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src_files := $( wildcard *.c) // 最终 src_files 中列出了当前目录下的所有.c 文件</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>$(filter pattern…,text)</p><p>把 text 中符合 pattern 格式的内容，filter(过滤)出来、留下来。</p><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-y := a.o b.o c/ d/</span><br><span class="line">DIR := <span class="variable">$(<span class="built_in">filter</span> %/, $(obj-y)</span>) //结果为：c/ d/</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>$(filter-out pattern…,text)</p><p>把 text 中符合 pattern 格式的内容，filter-out(过滤)出来、扔掉。</p><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-y := a.o b.o c/ d/</span><br><span class="line">DIR := <span class="variable">$(<span class="built_in">filter</span>-out %/, $(obj-y)</span>) //结果为：a.o b.o</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>$(patsubst pattern,replacement,text)</p><p>寻找”text”中符合格式”pattern”的字，用”replacement”替换它们。</p><p>“pattern”和”replacement”中可以使用通配符。</p><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subdir-y := c/ d/</span><br><span class="line">subdir-y := <span class="variable">$(<span class="built_in">patsubst</span> %/, %, $(subdir-y)</span>) // 结果为：c d</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【嵌入式】虚拟机Ubuntu环境配置</title>
      <link href="/2023/05/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/05/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】虚拟机Ubuntu环境配置"><a href="#【嵌入式】虚拟机Ubuntu环境配置" class="headerlink" title="【嵌入式】虚拟机Ubuntu环境配置"></a>【嵌入式】虚拟机Ubuntu环境配置</h1><h2 id="一键配置开发环境（此脚本只支持Ubuntu-16-04-Ubuntu-18-04）"><a href="#一键配置开发环境（此脚本只支持Ubuntu-16-04-Ubuntu-18-04）" class="headerlink" title="一键配置开发环境（此脚本只支持Ubuntu-16.04/Ubuntu-18.04）"></a>一键配置开发环境（此脚本只支持Ubuntu-16.04/Ubuntu-18.04）</h2><h3 id="在终端输入下面命令"><a href="#在终端输入下面命令" class="headerlink" title="在终端输入下面命令"></a>在终端输入下面命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://e.coding.net/weidongshan/DevelopmentEnvConf.git</span><br><span class="line"></span><br><span class="line">cd DevelopmentEnvConf</span><br><span class="line"></span><br><span class="line">sudo ./Configuring_ubuntu.sh</span><br></pre></td></tr></table></figure><h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><div class="tip error"><p>E: Problem executing scripts APT::Update::Post-Invoke-Success ‘if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli; then appstreamcli refresh &gt; /dev/null; fi’<br>E: Sub-process returned an error code</p></div><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><div class="tip success"><p>sudo apt upgrade</p></div>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
