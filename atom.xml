<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TayCcc</title>
  
  <subtitle>何时葡萄先熟透</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-05T08:26:23.196Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>TayCcc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Linux相机】摄像头模块</title>
    <link href="http://example.com/2024/05/05/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux%E7%9B%B8%E6%9C%BA/Linux%E7%9B%B8%E6%9C%BA/%E3%80%90V4L2%E5%9F%BA%E7%A1%80%E3%80%91%E6%91%84%E5%83%8F%E5%A4%B4APP/"/>
    <id>http://example.com/2024/05/05/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux%E7%9B%B8%E6%9C%BA/Linux%E7%9B%B8%E6%9C%BA/%E3%80%90V4L2%E5%9F%BA%E7%A1%80%E3%80%91%E6%91%84%E5%83%8F%E5%A4%B4APP/</id>
    <published>2024-05-05T08:23:16.000Z</published>
    <updated>2024-05-05T08:26:23.196Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【Linux相机】摄像头模块"><a href="#【Linux相机】摄像头模块" class="headerlink" title="【Linux相机】摄像头模块"></a>【Linux相机】摄像头模块</h1><p><strong>参考资料</strong></p><ul><li>韦东山嵌入式Linux相机</li></ul><h2 id="1-整体框架"><a href="#1-整体框架" class="headerlink" title="1.整体框架"></a>1.整体框架</h2><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405051521674.png" alt=""></p><p>​    下述代码只展示主要部分，全部代码等待上传</p><h3 id="1-1图像读取"><a href="#1-1图像读取" class="headerlink" title="1.1图像读取"></a>1.1图像读取</h3><p>​    思路如前面V4L2一样，不同之处是需要创建结构体来管理数据和函数。结构体大致如上图中所示。</p><ul><li><p>open 打开设备</p><ul><li><p>VIDIOC_QUERYCAP   确定它是否视频捕捉设备,支持哪种接口(streaming/read,write)</p></li><li><p>VIDIOC_ENUM_FMT 查询支持哪种格式</p></li><li><p>VIDIOC_S_FMT          设置摄像头使用哪种格式</p></li><li><p>VIDIOC_REQBUFS    申请buffer</p></li><li><p>对于 streaming:</p><ul><li>VIDIOC_QUERYBUF   确定每一个buffer的信息 并且 mmap</li><li>VIDIOC_QBUF            放入队列</li><li>VIDIOC_STREAMON 启动设备</li><li>poll                             等待有数据</li><li>VIDIOC_DQBUF        从队列中取出</li><li>处理….</li><li>VIDIOC_QBUF           放入队列</li></ul></li><li><p>对于read,write:</p><ul><li>read</li><li>处理….</li><li>read</li></ul></li><li><p>VIDIOC_STREAMOFF       停止设备</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;video_manager.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;disp_manager.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/videodev2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持的视频格式数组</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_aiSupportedFormats[] = &#123;V4L2_PIX_FMT_YUYV, V4L2_PIX_FMT_MJPEG, V4L2_PIX_FMT_RGB565&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查设备是否支持某种视频格式</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">isSupportThisFormat</span><span class="params">(<span class="type">int</span> iPixelFormat)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(g_aiSupportedFormats) / <span class="keyword">sizeof</span>(g_aiSupportedFormats[<span class="number">0</span>]); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_aiSupportedFormats[i] == iPixelFormat)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化视频设备</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">V4l2InitDevice</span><span class="params">(<span class="type">char</span> *strDevName, PT_VideoDevice ptVideoDevice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> iFd;</span><br><span class="line">    <span class="type">int</span> iError;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_capability</span> <span class="title">tV4l2Cap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_fmtdesc</span> <span class="title">tFmtDesc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> <span class="title">tV4l2Fmt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> <span class="title">tV4l2ReqBuffs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">tV4l2Buf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iLcdWidth;</span><br><span class="line">    <span class="type">int</span> iLcdHeight;</span><br><span class="line">    <span class="type">int</span> iLcdBpp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开设备文件</span></span><br><span class="line">    iFd = open(strDevName, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (iFd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DBG_PRINTF(<span class="string">&quot;can not open %s\n&quot;</span>, strDevName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptVideoDevice-&gt;iFd = iFd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询设备能力</span></span><br><span class="line">    iError = ioctl(iFd, VIDIOC_QUERYCAP, &amp;tV4l2Cap);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;tV4l2Cap, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_capability));</span><br><span class="line">    iError = ioctl(iFd, VIDIOC_QUERYCAP, &amp;tV4l2Cap);</span><br><span class="line">    <span class="keyword">if</span> (iError)</span><br><span class="line">    &#123;</span><br><span class="line">        DBG_PRINTF(<span class="string">&quot;Error opening device %s: unable to query device.\n&quot;</span>, strDevName);</span><br><span class="line">        <span class="keyword">goto</span> err_exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查设备是否支持视频捕获</span></span><br><span class="line">    <span class="keyword">if</span> (!(tV4l2Cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE))</span><br><span class="line">    &#123;</span><br><span class="line">        DBG_PRINTF(<span class="string">&quot;%s is not a video capture device\n&quot;</span>, strDevName);</span><br><span class="line">        <span class="keyword">goto</span> err_exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查设备是否支持流式输入输出</span></span><br><span class="line">    <span class="keyword">if</span> (tV4l2Cap.capabilities &amp; V4L2_CAP_STREAMING)</span><br><span class="line">    &#123;</span><br><span class="line">        DBG_PRINTF(<span class="string">&quot;%s supports streaming i/o\n&quot;</span>, strDevName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查设备是否支持读写操作</span></span><br><span class="line">    <span class="keyword">if</span> (tV4l2Cap.capabilities &amp; V4L2_CAP_READWRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        DBG_PRINTF(<span class="string">&quot;%s supports read i/o\n&quot;</span>, strDevName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举设备支持的视频格式</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tFmtDesc, <span class="number">0</span>, <span class="keyword">sizeof</span>(tFmtDesc));</span><br><span class="line">    tFmtDesc.index = <span class="number">0</span>;</span><br><span class="line">    tFmtDesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    <span class="keyword">while</span> ((iError = ioctl(iFd, VIDIOC_ENUM_FMT, &amp;tFmtDesc)) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSupportThisFormat(tFmtDesc.pixelformat))</span><br><span class="line">        &#123;</span><br><span class="line">            ptVideoDevice-&gt;iPixelFormat = tFmtDesc.pixelformat;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tFmtDesc.index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptVideoDevice-&gt;iPixelFormat)</span><br><span class="line">    &#123;</span><br><span class="line">        DBG_PRINTF(<span class="string">&quot;can not support the format of this device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置视频格式</span></span><br><span class="line">    GetDispResolution(&amp;iLcdWidth, &amp;iLcdHeight, &amp;iLcdBpp);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;tV4l2Fmt, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_format));</span><br><span class="line">    tV4l2Fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    tV4l2Fmt.fmt.pix.pixelformat = ptVideoDevice-&gt;iPixelFormat;</span><br><span class="line">    tV4l2Fmt.fmt.pix.width = iLcdWidth;</span><br><span class="line">    tV4l2Fmt.fmt.pix.height = iLcdHeight;</span><br><span class="line">    tV4l2Fmt.fmt.pix.field = V4L2_FIELD_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果驱动程序发现无法某些参数(比如分辨率),</span></span><br><span class="line"><span class="comment">     * 它会调整这些参数, 并且返回给应用程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    iError = ioctl(iFd, VIDIOC_S_FMT, &amp;tV4l2Fmt);</span><br><span class="line">    <span class="keyword">if</span> (iError)</span><br><span class="line">    &#123;</span><br><span class="line">        DBG_PRINTF(<span class="string">&quot;Unable to set format\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_exit;</span><br><span class="line">    &#125;</span><br><span class="line">    ptVideoDevice-&gt;iWidth = tV4l2Fmt.fmt.pix.width;</span><br><span class="line">    ptVideoDevice-&gt;iHeight = tV4l2Fmt.fmt.pix.height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求缓冲区</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tV4l2ReqBuffs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_requestbuffers));</span><br><span class="line">    tV4l2ReqBuffs.count = NB_BUFFER;</span><br><span class="line">    tV4l2ReqBuffs.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    tV4l2ReqBuffs.memory = V4L2_MEMORY_MMAP;</span><br><span class="line"></span><br><span class="line">    iError = ioctl(iFd, VIDIOC_REQBUFS, &amp;tV4l2ReqBuffs);</span><br><span class="line">    <span class="keyword">if</span> (iError)</span><br><span class="line">    &#123;</span><br><span class="line">        DBG_PRINTF(<span class="string">&quot;Unable to allocate buffers.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptVideoDevice-&gt;iVideoBufCnt = tV4l2ReqBuffs.count;</span><br><span class="line">    <span class="keyword">if</span> (tV4l2Cap.capabilities &amp; V4L2_CAP_STREAMING)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 映射缓冲区</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ptVideoDevice-&gt;iVideoBufCnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;tV4l2Buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_buffer));</span><br><span class="line">            tV4l2Buf.index = i;</span><br><span class="line">            tV4l2Buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">            tV4l2Buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">            iError = ioctl(iFd, VIDIOC_QUERYBUF, &amp;tV4l2Buf);</span><br><span class="line">            <span class="keyword">if</span> (iError)</span><br><span class="line">            &#123;</span><br><span class="line">                DBG_PRINTF(<span class="string">&quot;Unable to query buffer.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> err_exit;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ptVideoDevice-&gt;iVideoBufMaxLen = tV4l2Buf.length;</span><br><span class="line">            ptVideoDevice-&gt;pucVideoBuf[i] = mmap(<span class="number">0</span> <span class="comment">/* start anywhere */</span>,</span><br><span class="line">                                                  tV4l2Buf.length, PROT_READ, MAP_SHARED, iFd,</span><br><span class="line">                                                  tV4l2Buf.m.offset);</span><br><span class="line">            <span class="keyword">if</span> (ptVideoDevice-&gt;</span><br><span class="line"></span><br><span class="line">pucVideoBuf[i] == MAP_FAILED)</span><br><span class="line">            &#123;</span><br><span class="line">                DBG_PRINTF(<span class="string">&quot;Unable to map buffer\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> err_exit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将缓冲区加入队列</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ptVideoDevice-&gt;iVideoBufCnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;tV4l2Buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_buffer));</span><br><span class="line">            tV4l2Buf.index = i;</span><br><span class="line">            tV4l2Buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">            tV4l2Buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">            iError = ioctl(iFd, VIDIOC_QBUF, &amp;tV4l2Buf);</span><br><span class="line">            <span class="keyword">if</span> (iError)</span><br><span class="line">            &#123;</span><br><span class="line">                DBG_PRINTF(<span class="string">&quot;Unable to queue buffer.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> err_exit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tV4l2Cap.capabilities &amp; V4L2_CAP_READWRITE)</span><br><span class="line">    &#123;</span><br><span class="line">        g_tV4l2VideoOpr.GetFrame = V4l2GetFrameForReadWrite;</span><br><span class="line">        g_tV4l2VideoOpr.PutFrame = V4l2PutFrameForReadWrite;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read(fd, buf, size) */</span></span><br><span class="line">        ptVideoDevice-&gt;iVideoBufCnt = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 在这个程序所能支持的格式里, 一个像素最多只需要4字节 */</span></span><br><span class="line">        ptVideoDevice-&gt;iVideoBufMaxLen = ptVideoDevice-&gt;iWidth * ptVideoDevice-&gt;iHeight * <span class="number">4</span>;</span><br><span class="line">        ptVideoDevice-&gt;pucVideoBuf[<span class="number">0</span>] = <span class="built_in">malloc</span>(ptVideoDevice-&gt;iVideoBufMaxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptVideoDevice-&gt;ptOpr = &amp;g_tV4l2VideoOpr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_exit:</span><br><span class="line">    close(iFd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放视频设备资源</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">V4l2ExitDevice</span><span class="params">(PT_VideoDevice ptVideoDevice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ptVideoDevice-&gt;iVideoBufCnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptVideoDevice-&gt;pucVideoBuf[i])</span><br><span class="line">        &#123;</span><br><span class="line">            munmap(ptVideoDevice-&gt;pucVideoBuf[i], ptVideoDevice-&gt;iVideoBufMaxLen);</span><br><span class="line">            ptVideoDevice-&gt;pucVideoBuf[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(ptVideoDevice-&gt;iFd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于流式输入输出的获取帧函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">V4l2GetFrameForStreaming</span><span class="params">(PT_VideoDevice ptVideoDevice, PT_VideoBuf ptVideoBuf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">tFds</span>[1];</span></span><br><span class="line">    <span class="type">int</span> iRet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">tV4l2Buf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* poll */</span></span><br><span class="line">    tFds[<span class="number">0</span>].fd = ptVideoDevice-&gt;iFd;</span><br><span class="line">    tFds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">    iRet = poll(tFds, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (iRet &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DBG_PRINTF(<span class="string">&quot;poll error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* VIDIOC_DQBUF */</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tV4l2Buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_buffer));</span><br><span class="line">    tV4l2Buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    tV4l2Buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">    iRet = ioctl(ptVideoDevice-&gt;iFd, VIDIOC_DQBUF, &amp;tV4l2Buf);</span><br><span class="line">    <span class="keyword">if</span> (iRet &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DBG_PRINTF(<span class="string">&quot;Unable to dequeue buffer.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptVideoDevice-&gt;iVideoBufCurIndex = tV4l2Buf.index;</span><br><span class="line"></span><br><span class="line">    ptVideoBuf-&gt;iPixelFormat = ptVideoDevice-&gt;iPixelFormat;</span><br><span class="line">    ptVideoBuf-&gt;tPixelDatas.iWidth = ptVideoDevice-&gt;iWidth;</span><br><span class="line">    ptVideoBuf-&gt;tPixelDatas.iHeight = ptVideoDevice-&gt;iHeight;</span><br><span class="line">    ptVideoBuf-&gt;tPixelDatas.iBpp = (ptVideoDevice-&gt;iPixelFormat == V4L2_PIX_FMT_YUYV) ? <span class="number">16</span> : \</span><br><span class="line">                                    (ptVideoDevice-&gt;iPixelFormat == V4L2_PIX_FMT_MJPEG) ? <span class="number">0</span> :  \</span><br><span class="line">                                    (ptVideoDevice-&gt;iPixelFormat == V4L2_PIX_FMT_RGB565) ? <span class="number">16</span> :  \</span><br><span class="line">                                    <span class="number">0</span>;</span><br><span class="line">    ptVideoBuf-&gt;tPixelDatas.iLineBytes = ptVideoDevice-&gt;iWidth * ptVideoBuf-&gt;tPixelDatas.iBpp / <span class="number">8</span>;</span><br><span class="line">    ptVideoBuf-&gt;tPixelDatas.iTotalBytes = tV4l2Buf.bytesused;</span><br><span class="line">    ptVideoBuf-&gt;tPixelDatas.aucPixelDatas = ptVideoDevice-&gt;pucVideoBuf[tV4l2Buf.index];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于流式输入输出的放置帧函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">V4l2PutFrameForStreaming</span><span class="params">(PT_VideoDevice ptVideoDevice, PT_VideoBuf ptVideoBuf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* VIDIOC_QBUF */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">tV4l2Buf</span>;</span></span><br><span class="line">    <span class="type">int</span> iError;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tV4l2Buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_buffer));</span><br><span class="line">    tV4l2Buf.index = ptVideoDevice-&gt;iVideoBufCurIndex;</span><br><span class="line">    tV4l2Buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    tV4l2Buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">    iError = ioctl(ptVideoDevice-&gt;iFd, VIDIOC_QBUF, &amp;tV4l2Buf);</span><br><span class="line">    <span class="keyword">if</span> (iError)</span><br><span class="line">    &#123;</span><br><span class="line">        DBG_PRINTF(<span class="string">&quot;Unable to queue buffer.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于读写操作的获取帧函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">V4l2GetFrameForReadWrite</span><span class="params">(PT_VideoDevice ptVideoDevice, PT_VideoBuf ptVideoBuf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iRet;</span><br><span class="line"></span><br><span class="line">    iRet = read(ptVideoDevice-&gt;iFd, ptVideoDevice-&gt;pucVideoBuf[<span class="number">0</span>], ptVideoDevice-&gt;iVideoBufMaxLen);</span><br><span class="line">    <span class="keyword">if</span> (iRet &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptVideoBuf-&gt;iPixelFormat = ptVideoDevice-&gt;iPixelFormat;</span><br><span class="line">    ptVideoBuf-&gt;tPixelDatas.iWidth = ptVideoDevice-&gt;iWidth;</span><br><span class="line">    ptVideoBuf-&gt;tPixelDatas.iHeight = ptVideoDevice-&gt;iHeight;</span><br><span class="line">    ptVideoBuf-&gt;tPixelDatas.iBpp = (ptVideoDevice-&gt;iPixelFormat == V4L2_PIX_FMT_YUYV) ? <span class="number">16</span> : \</span><br><span class="line">                                    (ptVideoDevice-&gt;iPixelFormat == V4L2_PIX_FMT_MJPEG) ? <span class="number">0</span> :  \</span><br><span class="line">                                    (ptVideoDevice-&gt;iPixelFormat == V4L2_PIX_FMT_RGB565) ? <span class="number">16</span> : \</span><br><span class="line">                                      <span class="number">0</span>;</span><br><span class="line">    ptVideoBuf-&gt;tPixelDatas.iLineBytes = ptVideoDevice-&gt;iWidth * ptVideoBuf-&gt;tPixelDatas.iBpp / <span class="number">8</span>;</span><br><span class="line">    ptVideoBuf-&gt;tPixelDatas.iTotalBytes = iRet;</span><br><span class="line">    ptVideoBuf-&gt;tPixelDatas.aucPixelDatas = ptVideoDevice-&gt;pucVideoBuf[<span class="number">0</span></span><br><span class="line"></span><br><span class="line">];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于读写操作的放置帧函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">V4l2PutFrameForReadWrite</span><span class="params">(PT_VideoDevice ptVideoDevice, PT_VideoBuf ptVideoBuf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始视频设备采集</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">V4l2StartDevice</span><span class="params">(PT_VideoDevice ptVideoDevice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iType = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    <span class="type">int</span> iError;</span><br><span class="line"></span><br><span class="line">    iError = ioctl(ptVideoDevice-&gt;iFd, VIDIOC_STREAMON, &amp;iType);</span><br><span class="line">    <span class="keyword">if</span> (iError)</span><br><span class="line">    &#123;</span><br><span class="line">        DBG_PRINTF(<span class="string">&quot;Unable to start capture.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止视频设备采集</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">V4l2StopDevice</span><span class="params">(PT_VideoDevice ptVideoDevice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iType = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    <span class="type">int</span> iError;</span><br><span class="line"></span><br><span class="line">    iError = ioctl(ptVideoDevice-&gt;iFd, VIDIOC_STREAMOFF, &amp;iType);</span><br><span class="line">    <span class="keyword">if</span> (iError)</span><br><span class="line">    &#123;</span><br><span class="line">        DBG_PRINTF(<span class="string">&quot;Unable to stop capture.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取视频设备当前的格式</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">V4l2GetFormat</span><span class="params">(PT_VideoDevice ptVideoDevice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ptVideoDevice-&gt;iPixelFormat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造一个VideoOpr结构体</span></span><br><span class="line"><span class="type">static</span> T_VideoOpr g_tV4l2VideoOpr = &#123;</span><br><span class="line">    .name        = <span class="string">&quot;v4l2&quot;</span>,</span><br><span class="line">    .InitDevice  = V4l2InitDevice,</span><br><span class="line">    .ExitDevice  = V4l2ExitDevice,</span><br><span class="line">    .GetFormat   = V4l2GetFormat,</span><br><span class="line">    .GetFrame    = V4l2GetFrameForStreaming,</span><br><span class="line">    .PutFrame    = V4l2PutFrameForStreaming,</span><br><span class="line">    .StartDevice = V4l2StartDevice,</span><br><span class="line">    .StopDevice  = V4l2StopDevice,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册这个结构体</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">V4l2Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> RegisterVideoOpr(&amp;g_tV4l2VideoOpr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2格式转换"><a href="#1-2格式转换" class="headerlink" title="1.2格式转换"></a>1.2格式转换</h3><p>​    一共包含三种格式转换，Yuv2Rgb、Mjpeg2Rgb和Rgb2Rgb。这三种格式转换独立编码，统一在convert_manager中管理。</p><h4 id="1-2-1Yuv2Ggb"><a href="#1-2-1Yuv2Ggb" class="headerlink" title="1.2.1Yuv2Ggb"></a>1.2.1Yuv2Ggb</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;convert_manager.h&gt;</span> <span class="comment">// 包含视频转换管理器头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;color.h&gt;</span> <span class="comment">// 包含颜色定义头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// 包含标准库头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否支持从给定的输入格式转换到给定的输出格式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isSupportYuv2Rgb</span><span class="params">(<span class="type">int</span> iPixelFormatIn, <span class="type">int</span> iPixelFormatOut)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (iPixelFormatIn != V4L2_PIX_FMT_YUYV) <span class="comment">// 如果输入格式不是YUYV</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不支持转换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((iPixelFormatOut != V4L2_PIX_FMT_RGB565) &amp;&amp; (iPixelFormatOut != V4L2_PIX_FMT_RGB32)) <span class="comment">// 如果输出格式既不是RGB565也不是RGB32</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不支持转换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 支持转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将YUV422格式的数据转换为RGB565格式的数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Pyuv422torgb565</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *input_ptr, <span class="type">unsigned</span> <span class="type">char</span> *output_ptr, <span class="type">unsigned</span> <span class="type">int</span> image_width, <span class="type">unsigned</span> <span class="type">int</span> image_height)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i, size; <span class="comment">// 声明循环计数器和大小变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Y, Y1, U, V; <span class="comment">// 声明YUV422格式的数据中的Y、Y1、U、V分量变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *buff = input_ptr; <span class="comment">// 定义输入数据缓冲区指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *output_pt = output_ptr; <span class="comment">// 定义输出数据缓冲区指针</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r, g, b; <span class="comment">// 声明RGB分量变量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> color; <span class="comment">// 声明RGB565颜色值变量</span></span><br><span class="line">    </span><br><span class="line">size = image_width * image_height / <span class="number">2</span>; <span class="comment">// 计算数据大小</span></span><br><span class="line"><span class="keyword">for</span> (i = size; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 遍历每个像素对</span></span><br><span class="line">Y = buff[<span class="number">0</span>]; <span class="comment">// 获取Y分量</span></span><br><span class="line">U = buff[<span class="number">1</span>]; <span class="comment">// 获取U分量</span></span><br><span class="line">Y1 = buff[<span class="number">2</span>]; <span class="comment">// 获取Y1分量</span></span><br><span class="line">V = buff[<span class="number">3</span>]; <span class="comment">// 获取V分量</span></span><br><span class="line">buff += <span class="number">4</span>; <span class="comment">// 指向下一个像素对的数据</span></span><br><span class="line">r = R_FROMYV(Y,V); <span class="comment">// 计算红色分量</span></span><br><span class="line">g = G_FROMYUV(Y,U,V); <span class="comment">// 计算绿色分量</span></span><br><span class="line">b = B_FROMYU(Y,U); <span class="comment">// 计算蓝色分量</span></span><br><span class="line">        r = r &gt;&gt; <span class="number">3</span>; <span class="comment">// 取红色分量的高位5位</span></span><br><span class="line">        g = g &gt;&gt; <span class="number">2</span>; <span class="comment">// 取绿色分量的高位6位</span></span><br><span class="line">        b = b &gt;&gt; <span class="number">3</span>; <span class="comment">// 取蓝色分量的高位5位</span></span><br><span class="line">        color = (r &lt;&lt; <span class="number">11</span>) | (g &lt;&lt; <span class="number">5</span>) | b; <span class="comment">// 构造RGB565颜色值</span></span><br><span class="line">        *output_pt++ = color &amp; <span class="number">0xff</span>; <span class="comment">// 将低8位写入输出数据缓冲区</span></span><br><span class="line">        *output_pt++ = (color &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>; <span class="comment">// 将高8位写入输出数据缓冲区</span></span><br><span class="line"></span><br><span class="line">r = R_FROMYV(Y1,V); <span class="comment">// 计算红色分量</span></span><br><span class="line">g = G_FROMYUV(Y1,U,V); <span class="comment">// 计算绿色分量</span></span><br><span class="line">b = B_FROMYU(Y1,U); <span class="comment">// 计算蓝色分量</span></span><br><span class="line">        r = r &gt;&gt; <span class="number">3</span>; <span class="comment">// 取红色分量的高位5位</span></span><br><span class="line">        g = g &gt;&gt; <span class="number">2</span>; <span class="comment">// 取绿色分量的高位6位</span></span><br><span class="line">        b = b &gt;&gt; <span class="number">3</span>; <span class="comment">// 取蓝色分量的高位5位</span></span><br><span class="line">        color = (r &lt;&lt; <span class="number">11</span>) | (g &lt;&lt; <span class="number">5</span>) | b; <span class="comment">// 构造RGB565颜色值</span></span><br><span class="line">        *output_pt++ = color &amp; <span class="number">0xff</span>; <span class="comment">// 将低8位写入输出数据缓冲区</span></span><br><span class="line">        *output_pt++ = (color &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>; <span class="comment">// 将高8位写入输出数据缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将YUV422格式的数据转换为RGB32格式的数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Pyuv422torgb32</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *input_ptr, <span class="type">unsigned</span> <span class="type">char</span> *output_ptr, <span class="type">unsigned</span> <span class="type">int</span> image_width, <span class="type">unsigned</span> <span class="type">int</span> image_height)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i, size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Y, Y1, U, V;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *buff = input_ptr; <span class="comment">// 输入数据指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *output_pt = (<span class="type">unsigned</span> <span class="type">int</span>*)output_ptr; <span class="comment">// 输出数据指针</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r, g, b; <span class="comment">// 存储RGB分量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> color; <span class="comment">// 存储颜色值</span></span><br><span class="line"></span><br><span class="line">size = image_width * image_height / <span class="number">2</span>; <span class="comment">// 计算数据大小</span></span><br><span class="line"><span class="keyword">for</span> (i = size; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 循环处理每个像素对应的YUV数据</span></span><br><span class="line">Y = buff[<span class="number">0</span>]; <span class="comment">// 获取Y分量</span></span><br><span class="line">U = buff[<span class="number">1</span>]; <span class="comment">// 获取U分量</span></span><br><span class="line">Y1 = buff[<span class="number">2</span>]; <span class="comment">// 获取Y1分量</span></span><br><span class="line">V = buff[<span class="number">3</span>]; <span class="comment">// 获取V分量</span></span><br><span class="line">buff += <span class="number">4</span>; <span class="comment">// 移动指针到下一个像素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算RGB分量值</span></span><br><span class="line">        r = R_FROMYV(Y,V);</span><br><span class="line">g = G_FROMYUV(Y,U,V);</span><br><span class="line">b = B_FROMYU(Y,U);</span><br><span class="line"><span class="comment">// 构造32位RGB颜色值</span></span><br><span class="line">color = (r &lt;&lt; <span class="number">16</span>) | (g &lt;&lt; <span class="number">8</span>) | b;</span><br><span class="line">        *output_pt++ = color; <span class="comment">// 将颜色值存入输出缓冲区</span></span><br><span class="line"></span><br><span class="line">r = R_FROMYV(Y1,V);</span><br><span class="line">g = G_FROMYUV(Y1,U,V);</span><br><span class="line">b = B_FROMYU(Y1,U);</span><br><span class="line"><span class="comment">// 构造32位RGB颜色值</span></span><br><span class="line">color = (r &lt;&lt; <span class="number">16</span>) | (g &lt;&lt; <span class="number">8</span>) | b;</span><br><span class="line">        *output_pt++ = color; <span class="comment">// 将颜色值存入输出缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将YUV格式的图像数据转换为RGB格式的图像数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Yuv2RgbConvert</span><span class="params">(PT_VideoBuf ptVideoBufIn, PT_VideoBuf ptVideoBufOut)</span></span><br><span class="line">&#123;</span><br><span class="line">PT_PixelDatas ptPixelDatasIn = &amp;ptVideoBufIn-&gt;tPixelDatas; <span class="comment">// 获取输入图像数据信息</span></span><br><span class="line">PT_PixelDatas ptPixelDatasOut = &amp;ptVideoBufOut-&gt;tPixelDatas; <span class="comment">// 获取输出图像数据信息</span></span><br><span class="line"></span><br><span class="line">ptPixelDatasOut-&gt;iWidth = ptPixelDatasIn-&gt;iWidth; <span class="comment">// 设置输出图像宽度</span></span><br><span class="line">ptPixelDatasOut-&gt;iHeight = ptPixelDatasIn-&gt;iHeight; <span class="comment">// 设置输出图像高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptVideoBufOut-&gt;iPixelFormat == V4L2_PIX_FMT_RGB565) <span class="comment">// 如果输出格式为RGB565</span></span><br><span class="line">&#123;</span><br><span class="line">ptPixelDatasOut-&gt;iBpp = <span class="number">16</span>; <span class="comment">// 设置输出图像每像素位数</span></span><br><span class="line">ptPixelDatasOut-&gt;iLineBytes = ptPixelDatasOut-&gt;iWidth * ptPixelDatasOut-&gt;iBpp / <span class="number">8</span>; <span class="comment">// 计算每行字节数</span></span><br><span class="line">ptPixelDatasOut-&gt;iTotalBytes = ptPixelDatasOut-&gt;iLineBytes * ptPixelDatasOut-&gt;iHeight; <span class="comment">// 计算总字节数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ptPixelDatasOut-&gt;aucPixelDatas) <span class="comment">// 如果输出缓冲区为空</span></span><br><span class="line">&#123;</span><br><span class="line">ptPixelDatasOut-&gt;aucPixelDatas = <span class="built_in">malloc</span>(ptPixelDatasOut-&gt;iTotalBytes); <span class="comment">// 分配输出缓冲区内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pyuv422torgb565(ptPixelDatasIn-&gt;aucPixelDatas, ptPixelDatasOut-&gt;aucPixelDatas, ptPixelDatasOut-&gt;iWidth, ptPixelDatasOut-&gt;iHeight); <span class="comment">// 转换YUV422到RGB565</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ptVideoBufOut-&gt;iPixelFormat == V4L2_PIX_FMT_RGB32) <span class="comment">// 如果输出格式为RGB32</span></span><br><span class="line">&#123;</span><br><span class="line">ptPixelDatasOut-&gt;iBpp = <span class="number">32</span>; <span class="comment">// 设置输出图像每像素位数</span></span><br><span class="line">ptPixelDatasOut-&gt;iLineBytes = ptPixelDatasOut-&gt;iWidth * ptPixelDatasOut-&gt;iBpp / <span class="number">8</span>; <span class="comment">// 计算每行字节数</span></span><br><span class="line">ptPixelDatasOut-&gt;iTotalBytes = ptPixelDatasOut-&gt;iLineBytes * ptPixelDatasOut-&gt;iHeight; <span class="comment">// 计算总字节数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ptPixelDatasOut-&gt;aucPixelDatas) <span class="comment">// 如果输出缓冲区为空</span></span><br><span class="line">&#123;</span><br><span class="line">ptPixelDatasOut-&gt;aucPixelDatas = <span class="built_in">malloc</span>(ptPixelDatasOut-&gt;iTotalBytes); <span class="comment">// 分配输出缓冲区内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pyuv422torgb32(ptPixelDatasIn-&gt;aucPixelDatas, ptPixelDatasOut-&gt;aucPixelDatas, ptPixelDatasOut-&gt;iWidth, ptPixelDatasOut-&gt;iHeight); <span class="comment">// 转换YUV422到RGB32</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 返回失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放YUV到RGB转换的资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Yuv2RgbConvertExit</span><span class="params">(PT_VideoBuf ptVideoBufOut)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ptVideoBufOut-&gt;tPixelDatas.aucPixelDatas)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(ptVideoBufOut-&gt;tPixelDatas.aucPixelDatas);</span><br><span class="line">ptVideoBufOut-&gt;tPixelDatas.aucPixelDatas = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造结构体</span></span><br><span class="line"><span class="type">static</span> T_VideoConvert g_tYuv2RgbConvert = &#123;</span><br><span class="line">.name = <span class="string">&quot;yuv2rgb&quot;</span>,</span><br><span class="line">.isSupport = isSupportYuv2Rgb,</span><br><span class="line">.Convert = Yuv2RgbConvert,</span><br><span class="line">.ConvertExit = Yuv2RgbConvertExit,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册YUV到RGB转换</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Yuv2RgbInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">initLut();</span><br><span class="line"><span class="keyword">return</span> RegisterVideoConvert(&amp;g_tYuv2RgbConvert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="1-2-2Mjpeg2Rgb"><a href="#1-2-2Mjpeg2Rgb" class="headerlink" title="1.2.2Mjpeg2Rgb"></a>1.2.2Mjpeg2Rgb</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;convert_manager.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jpeglib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyErrorMgr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jpeg_error_mgr</span> <span class="title">pub</span>;</span></span><br><span class="line">jmp_buf setjmp_buffer;</span><br><span class="line">&#125; T_MyErrorMgr, *PT_MyErrorMgr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">jpeg_mem_src_tj</span><span class="params">(j_decompress_ptr, <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否支持将MJPEG格式转换为RGB格式</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">isSupportMjpeg2Rgb</span><span class="params">(<span class="type">int</span> iPixelFormatIn, <span class="type">int</span> iPixelFormatOut)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (iPixelFormatIn != V4L2_PIX_FMT_MJPEG)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((iPixelFormatOut != V4L2_PIX_FMT_RGB565) &amp;&amp; (iPixelFormatOut != V4L2_PIX_FMT_RGB32))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义libjpeg库出错处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">MyErrorExit</span><span class="params">(j_common_ptr ptCInfo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> errStr[JMSG_LENGTH_MAX];</span><br><span class="line">    </span><br><span class="line">PT_MyErrorMgr ptMyErr = (PT_MyErrorMgr)ptCInfo-&gt;err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the message */</span></span><br><span class="line">    (*ptCInfo-&gt;err-&gt;format_message) (ptCInfo, errStr);</span><br><span class="line">    DBG_PRINTF(<span class="string">&quot;%s\n&quot;</span>, errStr);</span><br><span class="line"></span><br><span class="line">longjmp(ptMyErr-&gt;setjmp_buffer, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一行像素数据从源格式转换为目标格式</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">CovertOneLine</span><span class="params">(<span class="type">int</span> iWidth, <span class="type">int</span> iSrcBpp, <span class="type">int</span> iDstBpp, <span class="type">unsigned</span> <span class="type">char</span> *pudSrcDatas, <span class="type">unsigned</span> <span class="type">char</span> *pudDstDatas)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dwRed;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dwGreen;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dwBlue;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dwColor;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwDstDatas16bpp = (<span class="type">unsigned</span> <span class="type">short</span> *)pudDstDatas;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *pwDstDatas32bpp = (<span class="type">unsigned</span> <span class="type">int</span> *)pudDstDatas;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (iSrcBpp != <span class="number">24</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (iDstBpp == <span class="number">24</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(pudDstDatas, pudSrcDatas, iWidth * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; iWidth; i++)</span><br><span class="line">&#123;</span><br><span class="line">dwRed = pudSrcDatas[pos++];</span><br><span class="line">dwGreen = pudSrcDatas[pos++];</span><br><span class="line">dwBlue = pudSrcDatas[pos++];</span><br><span class="line"><span class="keyword">if</span> (iDstBpp == <span class="number">32</span>)</span><br><span class="line">&#123;</span><br><span class="line">dwColor = (dwRed &lt;&lt; <span class="number">16</span>) | (dwGreen &lt;&lt; <span class="number">8</span>) | dwBlue;</span><br><span class="line">*pwDstDatas32bpp = dwColor;</span><br><span class="line">pwDstDatas32bpp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (iDstBpp == <span class="number">16</span>)</span><br><span class="line">&#123;</span><br><span class="line">dwRed = dwRed &gt;&gt; <span class="number">3</span>;</span><br><span class="line">dwGreen = dwGreen &gt;&gt; <span class="number">2</span>;</span><br><span class="line">dwBlue = dwBlue &gt;&gt; <span class="number">3</span>;</span><br><span class="line">dwColor = (dwRed &lt;&lt; <span class="number">11</span>) | (dwGreen &lt;&lt; <span class="number">5</span>) | dwBlue;</span><br><span class="line">*pwDstDatas16bpp = dwColor;</span><br><span class="line">pwDstDatas16bpp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将MJPEG格式的数据转换为RGB格式的数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">Mjpeg2RgbConvert</span><span class="params">(PT_VideoBuf ptVideoBufIn, PT_VideoBuf ptVideoBufOut)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jpeg_decompress_struct</span> <span class="title">tDInfo</span>;</span> <span class="comment">// JPEG解压缩结构体</span></span><br><span class="line"><span class="type">int</span> iRowStride; <span class="comment">// 行跨距</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *aucLineBuffer = <span class="literal">NULL</span>; <span class="comment">// 行缓冲区</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *pucDest; <span class="comment">// 目标缓冲区指针</span></span><br><span class="line">T_MyErrorMgr tJerr; <span class="comment">// 自定义错误管理器</span></span><br><span class="line">PT_PixelDatas ptPixelDatas = &amp;ptVideoBufOut-&gt;tPixelDatas; <span class="comment">// 输出图像像素数据结构体指针</span></span><br><span class="line"></span><br><span class="line">tDInfo.err = jpeg_std_error(&amp;tJerr.pub); <span class="comment">// 设置错误处理函数</span></span><br><span class="line">tJerr.pub.error_exit = MyErrorExit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (setjmp(tJerr.setjmp_buffer))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果程序运行到这里，表示JPEG解码出错</span></span><br><span class="line">jpeg_destroy_decompress(&amp;tDInfo);</span><br><span class="line"><span class="keyword">if</span> (aucLineBuffer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(aucLineBuffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ptPixelDatas-&gt;aucPixelDatas)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(ptPixelDatas-&gt;aucPixelDatas);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jpeg_create_decompress(&amp;tDInfo); <span class="comment">// 创建JPEG解压缩对象</span></span><br><span class="line"></span><br><span class="line">jpeg_mem_src_tj(&amp;tDInfo, ptVideoBufIn-&gt;tPixelDatas.aucPixelDatas, ptVideoBufIn-&gt;tPixelDatas.iTotalBytes); <span class="comment">// 将内存中的JPEG数据传递给解压缩对象</span></span><br><span class="line"></span><br><span class="line">jpeg_read_header(&amp;tDInfo, TRUE); <span class="comment">// 读取JPEG头信息</span></span><br><span class="line"></span><br><span class="line">tDInfo.scale_num = tDInfo.scale_denom = <span class="number">1</span>; <span class="comment">// 设置解压缩比例</span></span><br><span class="line"></span><br><span class="line">jpeg_start_decompress(&amp;tDInfo); <span class="comment">// 开始解压缩</span></span><br><span class="line"></span><br><span class="line">iRowStride = tDInfo.output_width * tDInfo.output_components; <span class="comment">// 计算行跨距</span></span><br><span class="line">aucLineBuffer = <span class="built_in">malloc</span>(iRowStride); <span class="comment">// 分配行缓冲区内存</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == aucLineBuffer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ptPixelDatas-&gt;iWidth = tDInfo.output_width; <span class="comment">// 设置输出图像宽度</span></span><br><span class="line">ptPixelDatas-&gt;iHeight = tDInfo.output_height; <span class="comment">// 设置输出图像高度</span></span><br><span class="line">ptPixelDatas-&gt;iLineBytes = ptPixelDatas-&gt;iWidth * ptPixelDatas-&gt;iBpp / <span class="number">8</span>; <span class="comment">// 计算每行字节数</span></span><br><span class="line">ptPixelDatas-&gt;iTotalBytes = ptPixelDatas-&gt;iLineBytes * ptPixelDatas-&gt;iHeight; <span class="comment">// 计算总字节数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == ptPixelDatas-&gt;aucPixelDatas)</span><br><span class="line">&#123;</span><br><span class="line">ptPixelDatas-&gt;aucPixelDatas = <span class="built_in">malloc</span>(ptPixelDatas-&gt;iTotalBytes); <span class="comment">// 分配输出图像像素数据内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pucDest = ptPixelDatas-&gt;aucPixelDatas; <span class="comment">// 初始化目标缓冲区指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (tDInfo.output_scanline &lt; tDInfo.output_height)</span><br><span class="line">&#123;</span><br><span class="line">(<span class="type">void</span>)jpeg_read_scanlines(&amp;tDInfo, &amp;aucLineBuffer, <span class="number">1</span>); <span class="comment">// 逐行读取JPEG数据</span></span><br><span class="line"></span><br><span class="line">CovertOneLine(ptPixelDatas-&gt;iWidth, <span class="number">24</span>, ptPixelDatas-&gt;iBpp, aucLineBuffer, pucDest); <span class="comment">// 转换一行像素数据</span></span><br><span class="line"></span><br><span class="line">pucDest += ptPixelDatas-&gt;iLineBytes; <span class="comment">// 更新目标缓冲区指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(aucLineBuffer); <span class="comment">// 释放行缓冲区内存</span></span><br><span class="line">jpeg_finish_decompress(&amp;tDInfo); <span class="comment">// 完成解压缩</span></span><br><span class="line">jpeg_destroy_decompress(&amp;tDInfo); <span class="comment">// 销毁解压缩对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放MJPEG转换为RGB的缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">Mjpeg2RgbConvertExit</span><span class="params">(PT_VideoBuf ptVideoBufOut)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ptVideoBufOut-&gt;tPixelDatas.aucPixelDatas)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(ptVideoBufOut-&gt;tPixelDatas.aucPixelDatas);</span><br><span class="line">ptVideoBufOut-&gt;tPixelDatas.aucPixelDatas = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造结构体</span></span><br><span class="line"><span class="type">static</span> T_VideoConvert g_tMjpeg2RgbConvert = &#123;</span><br><span class="line">.name = <span class="string">&quot;mjpeg2rgb&quot;</span>,</span><br><span class="line">.isSupport = isSupportMjpeg2Rgb,</span><br><span class="line">.Convert = Mjpeg2RgbConvert,</span><br><span class="line">.ConvertExit = Mjpeg2RgbConvertExit,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册MJPEG2RGB转换</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Mjpeg2RgbInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> RegisterVideoConvert(&amp;g_tMjpeg2RgbConvert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3Rgb2Rgb"><a href="#1-2-3Rgb2Rgb" class="headerlink" title="1.2.3Rgb2Rgb"></a>1.2.3Rgb2Rgb</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否支持RGB565格式到RGB565或RGB32格式的转换</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">isSupportRgb2Rgb</span><span class="params">(<span class="type">int</span> iPixelFormatIn, <span class="type">int</span> iPixelFormatOut)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (iPixelFormatIn != V4L2_PIX_FMT_RGB565)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((iPixelFormatOut != V4L2_PIX_FMT_RGB565) &amp;&amp; (iPixelFormatOut != V4L2_PIX_FMT_RGB32))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将RGB565格式的数据转换为RGB565或RGB32格式的数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">Rgb2RgbConvert</span><span class="params">(PT_VideoBuf ptVideoBufIn, PT_VideoBuf ptVideoBufOut)</span></span><br><span class="line">&#123;</span><br><span class="line">PT_PixelDatas ptPixelDatasIn = &amp;ptVideoBufIn-&gt;tPixelDatas;</span><br><span class="line">PT_PixelDatas ptPixelDatasOut = &amp;ptVideoBufOut-&gt;tPixelDatas;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> r, g, b;</span><br><span class="line"><span class="type">int</span> color;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwSrc = (<span class="type">unsigned</span> <span class="type">short</span> *)ptPixelDatasIn-&gt;aucPixelDatas;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *pdwDest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptVideoBufIn-&gt;iPixelFormat != V4L2_PIX_FMT_RGB565)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptVideoBufOut-&gt;iPixelFormat == V4L2_PIX_FMT_RGB565)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 输出为RGB565格式</span></span><br><span class="line">ptPixelDatasOut-&gt;iWidth = ptPixelDatasIn-&gt;iWidth;</span><br><span class="line">ptPixelDatasOut-&gt;iHeight = ptPixelDatasIn-&gt;iHeight;</span><br><span class="line">ptPixelDatasOut-&gt;iBpp = <span class="number">16</span>;</span><br><span class="line">ptPixelDatasOut-&gt;iLineBytes = ptPixelDatasOut-&gt;iWidth * ptPixelDatasOut-&gt;iBpp / <span class="number">8</span>;</span><br><span class="line">ptPixelDatasOut-&gt;iTotalBytes = ptPixelDatasOut-&gt;iLineBytes * ptPixelDatasOut-&gt;iHeight;</span><br><span class="line"><span class="keyword">if</span> (!ptPixelDatasOut-&gt;aucPixelDatas)</span><br><span class="line">&#123;</span><br><span class="line">ptPixelDatasOut-&gt;aucPixelDatas = <span class="built_in">malloc</span>(ptPixelDatasOut-&gt;iTotalBytes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(ptPixelDatasOut-&gt;aucPixelDatas, ptPixelDatasIn-&gt;aucPixelDatas, ptPixelDatasOut-&gt;iTotalBytes);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ptVideoBufOut-&gt;iPixelFormat == V4L2_PIX_FMT_RGB32)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 输出为RGB32格式</span></span><br><span class="line">ptPixelDatasOut-&gt;iWidth = ptPixelDatasIn-&gt;iWidth;</span><br><span class="line">ptPixelDatasOut-&gt;iHeight = ptPixelDatasIn-&gt;iHeight;</span><br><span class="line">ptPixelDatasOut-&gt;iBpp = <span class="number">32</span>;</span><br><span class="line">ptPixelDatasOut-&gt;iLineBytes = ptPixelDatasOut-&gt;iWidth * ptPixelDatasOut-&gt;iBpp / <span class="number">8</span>;</span><br><span class="line">ptPixelDatasOut-&gt;iTotalBytes = ptPixelDatasOut-&gt;iLineBytes * ptPixelDatasOut-&gt;iHeight;</span><br><span class="line"><span class="keyword">if</span> (!ptPixelDatasOut-&gt;aucPixelDatas)</span><br><span class="line">&#123;</span><br><span class="line">ptPixelDatasOut-&gt;aucPixelDatas = <span class="built_in">malloc</span>(ptPixelDatasOut-&gt;iTotalBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pdwDest = (<span class="type">unsigned</span> <span class="type">int</span> *)ptPixelDatasOut-&gt;aucPixelDatas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; ptPixelDatasOut-&gt;iHeight; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; ptPixelDatasOut-&gt;iWidth; x++)</span><br><span class="line">&#123;</span><br><span class="line">color = *pwSrc++;</span><br><span class="line">r = color &gt;&gt; <span class="number">11</span>;</span><br><span class="line">g = (color &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x3f</span>;</span><br><span class="line">b = color &amp; <span class="number">0x1f</span>;</span><br><span class="line"></span><br><span class="line">color = ((r &lt;&lt; <span class="number">3</span>) &lt;&lt; <span class="number">16</span> | (g &lt;&lt; <span class="number">2</span>) &lt;&lt; <span class="number">8</span> | (b &lt;&lt; <span class="number">3</span>)); <span class="comment">// 转换为RGB32格式</span></span><br><span class="line">*pdwDest = color;</span><br><span class="line">pdwDest++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放RGB2RGB转换产生的输出缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">Rgb2RgbConvertExit</span><span class="params">(PT_VideoBuf ptVideoBufOut)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ptVideoBufOut-&gt;tPixelDatas.aucPixelDatas)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(ptVideoBufOut-&gt;tPixelDatas.aucPixelDatas);</span><br><span class="line">ptVideoBufOut-&gt;tPixelDatas.aucPixelDatas = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造结构体</span></span><br><span class="line"><span class="type">static</span> T_VideoConvert g_tRgb2RgbConvert = &#123;</span><br><span class="line">.name = <span class="string">&quot;rgb2rgb&quot;</span>,</span><br><span class="line">.isSupport = isSupportRgb2Rgb,</span><br><span class="line">.Convert = Rgb2RgbConvert,</span><br><span class="line">.ConvertExit = Rgb2RgbConvertExit,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册RGB2RGB转换</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Rgb2RgbInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> RegisterVideoConvert(&amp;g_tRgb2RgbConvert);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-缩放、合并和输出"><a href="#1-3-缩放、合并和输出" class="headerlink" title="1.3 缩放、合并和输出"></a>1.3 缩放、合并和输出</h3><p>​    剩下的三个操作统一放到main.c中实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;disp_manager.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;video_manager.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;convert_manager.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;render.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// video2lcd &lt;/dev/video0,1,...&gt;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 初始化变量</span></span><br><span class="line"><span class="type">int</span> iError;</span><br><span class="line">PT_VideoConvert ptVideoConvert;</span><br><span class="line">T_VideoBuf tFrameBuf;</span><br><span class="line">T_VideoDevice tVideoDevice;</span><br><span class="line"><span class="type">int</span> iPixelFormatOfDisp;</span><br><span class="line"><span class="type">int</span> iPixelFormatOfVideo;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iLcdWidth;</span><br><span class="line"><span class="type">int</span> iLcdHeight;</span><br><span class="line"><span class="type">int</span> iLcdBpp;</span><br><span class="line"></span><br><span class="line">PT_VideoBuf ptVideoBufCur;</span><br><span class="line">T_VideoBuf tVideoBuf;</span><br><span class="line">T_VideoBuf tConvertBuf;</span><br><span class="line">T_VideoBuf tZoomBuf;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iTopLeftX;</span><br><span class="line"><span class="type">int</span> iTopLeftY;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查命令行参数</span></span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &lt;/dev/video0,1,...&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化显示设备</span></span><br><span class="line">DisplayInit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取默认显示设备并初始化</span></span><br><span class="line">SelectAndInitDefaultDispDev(<span class="string">&quot;fb&quot;</span>);</span><br><span class="line">GetDispResolution(&amp;iLcdWidth, &amp;iLcdHeight, &amp;iLcdBpp);</span><br><span class="line">GetVideoBufForDisplay(&amp;tFrameBuf);</span><br><span class="line">iPixelFormatOfDisp = tFrameBuf.iPixelFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化视频设备</span></span><br><span class="line">VideoInit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化视频设备并获取视频数据格式</span></span><br><span class="line">iError = VideoDeviceInit(argv[<span class="number">1</span>], &amp;tVideoDevice);</span><br><span class="line"><span class="keyword">if</span>(iError)</span><br><span class="line">&#123;</span><br><span class="line">DBG_PRINTF(<span class="string">&quot;VideoDeviceInit for %s error!\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">iPixelFormatOfVideo = tVideoDevice.ptOpr-&gt;GetFormat(&amp;tVideoDevice);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化视频转换器</span></span><br><span class="line">VideoConvertInit();</span><br><span class="line">ptVideoConvert = GetVideoConvertForFormats(iPixelFormatOfVideo, iPixelFormatOfDisp);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == ptVideoConvert)</span><br><span class="line">&#123;</span><br><span class="line">DBG_PRINTF(<span class="string">&quot;can not support this format convert\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动视频设备</span></span><br><span class="line">iError = tVideoDevice.ptOpr-&gt;StartDevice(&amp;tVideoDevice);</span><br><span class="line"><span class="keyword">if</span>(iError)</span><br><span class="line">&#123;</span><br><span class="line">DBG_PRINTF(<span class="string">&quot;StartDevice for %s error!\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化视频帧数据结构</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;tVideoBuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(tVideoBuf));</span><br><span class="line"><span class="built_in">memset</span>(&amp;tConvertBuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(tConvertBuf));</span><br><span class="line">tConvertBuf.iPixelFormat = iPixelFormatOfDisp;</span><br><span class="line">tConvertBuf.tPixelDatas.iBpp = iLcdBpp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;tZoomBuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(tZoomBuf));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取视频帧</span></span><br><span class="line">iError = tVideoDevice.ptOpr-&gt;GetFrame(&amp;tVideoDevice, &amp;tVideoBuf);</span><br><span class="line"><span class="keyword">if</span>(iError)</span><br><span class="line">&#123;</span><br><span class="line">DBG_PRINTF(<span class="string">&quot;GetFrame for %s error!\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ptVideoBufCur = &amp;tVideoBuf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果视频格式与显示格式不同，则进行转换</span></span><br><span class="line"><span class="keyword">if</span>(iPixelFormatOfVideo != iPixelFormatOfDisp)</span><br><span class="line">&#123;</span><br><span class="line">iError = ptVideoConvert-&gt;Convert(&amp;tVideoBuf, &amp;tConvertBuf);</span><br><span class="line">DBG_PRINTF(<span class="string">&quot;Convert %s, ret = %d\n&quot;</span>, ptVideoConvert-&gt;name, iError);</span><br><span class="line"><span class="keyword">if</span>(iError)</span><br><span class="line">&#123;</span><br><span class="line">DBG_PRINTF(<span class="string">&quot;Convert for %s error!\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ptVideoBufCur = &amp;tConvertBuf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果视频帧大小大于LCD分辨率，则进行缩放</span></span><br><span class="line"><span class="keyword">if</span>(ptVideoBufCur-&gt;tPixelDatas.iWidth &gt; iLcdWidth || ptVideoBufCur-&gt;tPixelDatas.iHeight &gt; iLcdHeight)</span><br><span class="line">&#123;</span><br><span class="line">k = (<span class="type">float</span>)ptVideoBufCur-&gt;tPixelDatas.iHeight / ptVideoBufCur-&gt;tPixelDatas.iWidth;</span><br><span class="line">tZoomBuf.tPixelDatas.iWidth = iLcdWidth;</span><br><span class="line">tZoomBuf.tPixelDatas.iHeight = iLcdWidth * k;</span><br><span class="line"><span class="keyword">if</span>(tZoomBuf.tPixelDatas.iHeight &gt; iLcdHeight)</span><br><span class="line">&#123;</span><br><span class="line">tZoomBuf.tPixelDatas.iWidth = iLcdHeight / k;</span><br><span class="line">tZoomBuf.tPixelDatas.iHeight = iLcdHeight;</span><br><span class="line">&#125;</span><br><span class="line">tZoomBuf.tPixelDatas.iBpp = iLcdBpp;</span><br><span class="line">tZoomBuf.tPixelDatas.iLineBytes = tZoomBuf.tPixelDatas.iWidth * tZoomBuf.tPixelDatas.iBpp / <span class="number">8</span>;</span><br><span class="line">tZoomBuf.tPixelDatas.iTotalBytes = tZoomBuf.tPixelDatas.iLineBytes * tZoomBuf.tPixelDatas.iHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!tZoomBuf.tPixelDatas.aucPixelDatas)</span><br><span class="line">&#123;</span><br><span class="line">tZoomBuf.tPixelDatas.aucPixelDatas = <span class="built_in">malloc</span>(tZoomBuf.tPixelDatas.iTotalBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PicZoom(&amp;ptVideoBufCur-&gt;tPixelDatas, &amp;tZoomBuf.tPixelDatas);</span><br><span class="line">ptVideoBufCur = &amp;tZoomBuf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算显示视频帧的左上角坐标</span></span><br><span class="line">iTopLeftX = (iLcdWidth - ptVideoBufCur-&gt;tPixelDatas.iWidth) / <span class="number">2</span>;</span><br><span class="line">iTopLeftY = (iLcdHeight - ptVideoBufCur-&gt;tPixelDatas.iHeight) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将视频帧合成到显示帧缓冲区中</span></span><br><span class="line">PicMerge(iTopLeftX, iTopLeftY, &amp;ptVideoBufCur-&gt;tPixelDatas, &amp;tFrameBuf.tPixelDatas);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新显示帧缓冲区到显示设备</span></span><br><span class="line">FlushPixelDatasToDev(&amp;tFrameBuf.tPixelDatas);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将视频帧放回视频设备</span></span><br><span class="line">iError = tVideoDevice.ptOpr-&gt;PutFrame(&amp;tVideoDevice, &amp;tVideoBuf);</span><br><span class="line"><span class="keyword">if</span>(iError)</span><br><span class="line">&#123;</span><br><span class="line">DBG_PRINTF(<span class="string">&quot;PutFrame for %s error!\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【V4L2基础】摄像头APP</title>
    <link href="http://example.com/2024/05/04/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux%E7%9B%B8%E6%9C%BA/V4L2%E5%9F%BA%E7%A1%80/%E3%80%90V4L2%E5%9F%BA%E7%A1%80%E3%80%91%E6%91%84%E5%83%8F%E5%A4%B4APP/"/>
    <id>http://example.com/2024/05/04/%E5%B5%8C%E5%85%A5%E5%BC%8F/Linux%E7%9B%B8%E6%9C%BA/V4L2%E5%9F%BA%E7%A1%80/%E3%80%90V4L2%E5%9F%BA%E7%A1%80%E3%80%91%E6%91%84%E5%83%8F%E5%A4%B4APP/</id>
    <published>2024-05-04T09:13:13.000Z</published>
    <updated>2024-05-05T07:27:06.882Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【V4L2基础】摄像头APP"><a href="#【V4L2基础】摄像头APP" class="headerlink" title="【V4L2基础】摄像头APP"></a>【V4L2基础】摄像头APP</h1><p><strong>参考资料</strong></p><ul><li>mjpg-streamer：<a href="https://github.com/jacksonliam/mjpg-streamer">https://github.com/jacksonliam/mjpg-streamer</a></li><li>video2lcd：百问网编写的APP，可在LCD上直接显示摄像头图像</li><li>USB Video Class（UVC）参考文章：<a href="https://www.xjx100.cn/news/700965.html?action=onClick">https://www.xjx100.cn/news/700965.html?action=onClick</a></li></ul><h2 id="1-流程"><a href="#1-流程" class="headerlink" title="1.流程"></a>1.流程</h2><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041441263.png" alt="流程"></p><ul><li><p>open：打开设备节点/dev/videoX</p></li><li><p>ioctl VIDIOC_QUERYCAP：Query Capability，查询能力</p><ul><li>确认设备是否为“捕获设备”，因为有些节点是输出设备</li><li>确认设备是否支持mmap操作，还是仅支持read/write操作</li></ul></li><li><p>ioctl VIDIOC_ENUM_FMT：枚举设备支持的格式</p></li><li><p>ioctl VIDIOC_S_FMT：在枚举出来的格式中，选择一个来设置格式</p></li><li><p>ioctl VIDIOC_REQBUFS：申请Buffer，APP可以申请很多个Buffer，但是驱动程序不一定能申请到</p></li><li><p>ioctl VIDIOC_QUERYBUF和mmap：查询Buffer信息、映射</p><ul><li>如果申请到N个Buffer，这个ioctl就应该执行N次</li><li>执行mmap后，APP就可以直接读写这些Buffer</li></ul></li><li><p>ioctl VIDIOC_QBUF：把Buffer放入“空闲链表“</p><ul><li>如果申请到N个Buffer，这个ioctl就应该执行N次</li></ul></li><li><p>ioctl VIDIOC_STREAMON：启动摄像头</p></li><li><p>循环监测：使用poll/select监测Buffer，驱动程序采集数据放入Buffer并将Buffer放入”完成链表“，然后从”完成链表“中取出Buffer，处理后再放入”空闲链表“</p><ul><li>poll/select</li><li>ioctl VIDIOC_DQBUF：从”完成链表“中取出Buffer</li><li>处理前面使用mmap映射了每个Buffer的地址，处理时就可以直接使用地址来访问Buffer</li><li>ioctl VIDIOC_QBUF：把Buffer放入”空闲链表“</li></ul><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041535305.png" alt=""></p></li><li><p>ioctl VIDIOC_STREAMOFF：停止摄像头</p></li></ul><h2 id="2-控制流程"><a href="#2-控制流程" class="headerlink" title="2.控制流程"></a>2.控制流程</h2><p>使用摄像头时，我们可以调整很多参数，比如：</p><ul><li><p>对于视频流本身：</p><ul><li>设置格式：比如V4L2_PIX_FMT_YUYV、V4L2_PIX_FMT_MJPEG、V4L2_PIX_FMT_RGB565</li><li>设置分辨率：1024*768等</li></ul></li><li><p>对于控制部分：</p><ul><li>调节亮度</li><li>调节对比度</li><li>调节色度</li></ul></li></ul><h3 id="2-1-APP接口"><a href="#2-1-APP接口" class="headerlink" title="2.1 APP接口"></a>2.1 APP接口</h3><p>就APP而言，对于这些参数由3套接口：查询或枚举(Query/Enum)、获得(Get)、设置(Set)。</p><h4 id="2-1-1-数据格式"><a href="#2-1-1-数据格式" class="headerlink" title="2.1.1 数据格式"></a>2.1.1 数据格式</h4><p>以设置数据格式为例，可以先枚举：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_fmtdesc</span> <span class="title">fmtdesc</span>;</span></span><br><span class="line">fmtdesc.index = <span class="number">0</span>;  <span class="comment">// 比如从0开始</span></span><br><span class="line">fmtdesc.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;  <span class="comment">// 指定type为&quot;捕获&quot;</span></span><br><span class="line">ioctl(vd-&gt;fd, VIDIOC_ENUM_FMT, &amp;fmtdesc);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *F O R M A T   E N U M E R A T I O N</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_fmtdesc</span> &#123;</span></span><br><span class="line">__u32    index;             <span class="comment">/* Format number      */</span></span><br><span class="line">__u32    type;              <span class="comment">/* enum v4l2_buf_type */</span></span><br><span class="line">__u32               flags;</span><br><span class="line">__u8    description[<span class="number">32</span>];   <span class="comment">/* Description string */</span></span><br><span class="line">__u32    pixelformat;       <span class="comment">/* Format fourcc      */</span></span><br><span class="line">__u32    reserved[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还可以获得当前的格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> <span class="title">currentFormat</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;currentFormat, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_format));</span><br><span class="line">currentFormat.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">ioctl(vd-&gt;fd, VIDIOC_G_FMT, &amp;currentFormat);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> &#123;</span></span><br><span class="line">__u32 type;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_pix_format</span><span class="title">pix</span>;</span>     <span class="comment">/* V4L2_BUF_TYPE_VIDEO_CAPTURE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_pix_format_mplane</span><span class="title">pix_mp</span>;</span>  <span class="comment">/* V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_window</span><span class="title">win</span>;</span>     <span class="comment">/* V4L2_BUF_TYPE_VIDEO_OVERLAY */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_vbi_format</span><span class="title">vbi</span>;</span>     <span class="comment">/* V4L2_BUF_TYPE_VBI_CAPTURE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_sliced_vbi_format</span><span class="title">sliced</span>;</span>  <span class="comment">/* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_sdr_format</span><span class="title">sdr</span>;</span>     <span class="comment">/* V4L2_BUF_TYPE_SDR_CAPTURE */</span></span><br><span class="line">__u8raw_data[<span class="number">200</span>];                   <span class="comment">/* user-defined */</span></span><br><span class="line">&#125; fmt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *V I D E O   I M A G E   F O R M A T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_pix_format</span> &#123;</span>v4l2_format</span><br><span class="line">__u32         width;</span><br><span class="line">__u32height;</span><br><span class="line">__u32pixelformat;</span><br><span class="line">__u32field;<span class="comment">/* enum v4l2_field */</span></span><br><span class="line">__u32            bytesperline;<span class="comment">/* for padding, zero if unused */</span></span><br><span class="line">__u32          sizeimage;</span><br><span class="line">__u32colorspace;<span class="comment">/* enum v4l2_colorspace */</span></span><br><span class="line">__u32priv;<span class="comment">/* private data, depends on pixelformat */</span></span><br><span class="line">__u32flags;<span class="comment">/* format flags (V4L2_PIX_FMT_FLAG_*) */</span></span><br><span class="line">__u32ycbcr_enc;<span class="comment">/* enum v4l2_ycbcr_encoding */</span></span><br><span class="line">__u32quantization;<span class="comment">/* enum v4l2_quantization */</span></span><br><span class="line">__u32xfer_func;<span class="comment">/* enum v4l2_xfer_func */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以设置当前的格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> <span class="title">fmt</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;fmt, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_format));</span><br><span class="line">fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">fmt.fmt.pix.width = <span class="number">1024</span>;</span><br><span class="line">fmt.fmt.pix.height = <span class="number">768</span>;</span><br><span class="line">fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;</span><br><span class="line">fmt.fmt.pix.field = V4L2_FIELD_ANY;</span><br><span class="line"><span class="type">int</span> ret = ioctl(vd-&gt;fd, VIDIOC_S_FMT, &amp;fmt);</span><br></pre></td></tr></table></figure><p>若不支持手动设置的分辨率，将自动调整适当的分辨率</p><h4 id="2-1-2-选择输入源"><a href="#2-1-2-选择输入源" class="headerlink" title="2.1.2 选择输入源"></a>2.1.2 选择输入源</h4><p>可以获得当前输入源、设置当前输入源：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value;</span><br><span class="line">ioctl(h-&gt;fd,VIDIOC_G_INPUT,&amp;value);  <span class="comment">// 读到的value从0开始, 0表示第1个input源</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value = <span class="number">0</span>;  <span class="comment">// 0表示第1个input源</span></span><br><span class="line">ioctl(h-&gt;fd,VIDIOC_S_INPUT,&amp;value)</span><br></pre></td></tr></table></figure><h4 id="2-1-3-其他参数"><a href="#2-1-3-其他参数" class="headerlink" title="2.1.3 其他参数"></a>2.1.3 其他参数</h4><p>如果每一参数都提供一系列的ioctl cmd，那使用起来很不方便。</p><p>对于这些参数，APP使用对应ID来选中它，然后使用VIDIOC_QUERYCTRL、VIDIOC_G_CTRL、VIDIOC_S_CTRL来操作它。</p><p>不同参数的ID值不同。</p><p>以亮度Brightness为例，有如下调用方法:</p><ul><li>查询：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_queryctrl</span>   <span class="title">qctrl</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;qctrl, <span class="number">0</span>, <span class="keyword">sizeof</span>(qctrl));</span><br><span class="line">qctrl.id = V4L2_CID_BRIGHTNESS; <span class="comment">// V4L2_CID_BASE+0;</span></span><br><span class="line">ioctl(fd, VIDIOC_QUERYCTRL, &amp;qctrl);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_queryctrl</span> &#123;</span></span><br><span class="line">__u32     id;</span><br><span class="line">__u32     type;<span class="comment">/* enum v4l2_ctrl_type */</span></span><br><span class="line">__u8     name[<span class="number">32</span>];<span class="comment">/* Whatever */</span></span><br><span class="line">__s32     minimum;<span class="comment">/* Note signedness */</span></span><br><span class="line">__s32     maximum;</span><br><span class="line">__s32     step;</span><br><span class="line">__s32     default_value;</span><br><span class="line">__u32                flags;</span><br><span class="line">__u32     reserved[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>获得当前值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_control</span> <span class="title">c</span>;</span></span><br><span class="line">c.id = V4L2_CID_BRIGHTNESS; <span class="comment">// V4L2_CID_BASE+0;</span></span><br><span class="line">ioctl(h-&gt;fd, VIDIOC_G_CTRL, &amp;c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *C O N T R O L S</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_control</span> &#123;</span></span><br><span class="line">__u32     id;</span><br><span class="line">__s32     value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>设置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_control</span> <span class="title">c</span>;</span></span><br><span class="line">c.id = V4L2_CID_BRIGHTNESS; <span class="comment">// V4L2_CID_BASE+0;</span></span><br><span class="line">c.value = <span class="number">99</span>;</span><br><span class="line">ioctl(h-&gt;fd, VIDIOC_S_CTRL, &amp;c);</span><br></pre></td></tr></table></figure><h3 id="2-2-理解接口"><a href="#2-2-理解接口" class="headerlink" title="2.2 理解接口"></a>2.2 理解接口</h3><h4 id="2-2-1-概念"><a href="#2-2-1-概念" class="headerlink" title="2.2.1 概念"></a>2.2.1 概念</h4><p>以USB摄像头为例，它的内部结构如下：</p><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041626666.png" alt=""></p><p>一个USB摄像头必定有一个VideoControl接口，用于控制。有0个或多个VideoStreaming接口，用于传输视频。</p><p>在VideoControl内部，有多个Unit或Terminal，上一个Unit或Terminal的数据，流向下一个Unit或Terminal，多个Unit或Terminal组成一个完整的UVC功能设备。</p><ul><li><p>只有一个输出引脚<br><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041627242.png" alt="11_unit_example"></p></li><li><p>可以Fan-out，不能Fan-in<br><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041628950.png" alt="12_fanout_fanin"></p></li><li><p>Terminal：位于边界，用于联通外界。有：IT(Input Terminal)、OT(Output Terminal)、CT(Camera Terminal)。模型如下，有一个输出引脚：</p><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041628101.png" alt="08_itot"></p></li><li><p>Unit：位于VideoControl内部，用来进行各种控制</p><ul><li>SU：Selector Unit(选择单元)，从多路输入中选择一路，比如设备支持多种输入源，可以通过SU进行选择切换。模型如下<br><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041628367.png" alt="09_su"></li><li>PU：Porocessing Unit(处理单元)，用于调整亮度、对比度、色度等，有如下控制功能：<ul><li>User Controls<ul><li>Brightness 背光</li><li>Hue 色度</li><li>Saturation 饱和度</li><li>Sharpness 锐度</li><li>Gamma 伽马</li><li>Digital Multiplier (Zoom) 数字放大</li></ul></li><li>Auto Controls<ul><li>White Balance Temperature 白平衡色温</li><li>White Balance Component 白平衡组件</li><li>Backlight Compensation 背光补偿</li><li>Contrast 对比度</li></ul></li><li>Other<ul><li>Gain 增益</li><li>Power Line Frequency 电源线频率</li><li>Analog Video Standard 模拟视频标准</li><li>Analog Video Lock Status 模拟视频锁状态</li></ul></li><li>模型如下<br><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041628168.png" alt="10_pu"></li></ul></li><li>EU：Encoding Unit(编码单元)，对采集所得的数据进行个性化处理的功能。编码单元控制编码器的属性，该编码器对通过它流式传输的视频进行编码。它具有如下功能：<br><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041628946.png" alt="13_eu_functions"></li><li>模型如下<br><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041629506.png" alt="14_eu"></li></ul></li><li><p>XU：Extension Unit(扩展单元)，厂家可以在XU上提供自定义的操作，模型如下：<br><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041629400.png" alt="15_xu"></p></li></ul><h4 id="2-2-2-操作方法"><a href="#2-2-2-操作方法" class="headerlink" title="2.2.2 操作方法"></a>2.2.2 操作方法</h4><p>我们使用ioctl操作设备节点”/dev/video0”时，不同的ioctl操作的可能是VideoControl接口，或者VideoStreaming接口。</p><p>跟视频流相关的操作，比如：VIDIOC_ENUM_FMT、VIDIOC_G_FMT、VIDIOC_S_FMT、VIDIOC_STREAMON、VIDIOC_STREAMOFF，是操作VideoStreaming接口。</p><p>其他ioctl，大多都是操作VideoControl接口。</p><p>从底层驱动和硬件角度看，要操作VideoControl接口，需要指明：</p><ul><li>entity：你要操作哪个Terminal或Unit，比如PU</li><li>Control Selector：你要操作entity里面的哪个控制项？比如亮度PU_BRIGHTNESS_CONTROL</li><li>控制项里哪些位：比如CT(Camera Terminal)里的CT_PANTILT_RELATIVE_CONTROL控制项对应32位的数据，其中前16位对应PAN控制(左右转动)，后16位对应TILE控制(上下转动)</li></ul><p>但是APP不关注这些细节，使用一个ID来指定entity、Control Selector、哪些位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *C O N T R O L S</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_control</span> &#123;</span></span><br><span class="line">__u32     id;</span><br><span class="line">__s32     value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>驱动程序里，会解析APP传入的ID，找到entity、Control Selector、那些位。</p><p>有了上述知识后，才能看懂mjpg-streamer的如下代码：</p><ul><li><p>XU：使用比较老的UVC驱动时，需要APP传入厂家的XU信息；新驱动里可以解析出XU信息，无需APP传入<br><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041629674.png" alt="16_logitech_xu"></p></li><li><p>mapping：无论新老UVC驱动，都需要提供更细化的mapping信息</p><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041629606.png" alt="17_logitech_mapping"></p></li><li><p>代码如下<br><img src="https://gitee.com/tayccc/picgo/raw/master/img/202405041630032.png" alt="18_add_control_mapping"></p></li></ul><h2 id="3-编写APP"><a href="#3-编写APP" class="headerlink" title="3. 编写APP"></a>3. 编写APP</h2><p>参考：mjpg-streamer，<a href="https://github.com/jacksonliam/mjpg-streamer">https://github.com/jacksonliam/mjpg-streamer</a></p><h3 id="3-1-列出帧细节"><a href="#3-1-列出帧细节" class="headerlink" title="3.1 列出帧细节"></a>3.1 列出帧细节</h3><p>调用ioctl VIDIOC_ENUM_FMT可以枚举摄像头支持的格式，但是无法获得更多细节（比如支持哪些分辨率），</p><p>调用ioctl VIDIOC_G_FMT可以获得”当前的格式”，包括分辨率等细节，但是无法获得其他格式的细节。</p><p>需要结合VIDIOC_ENUM_FMT、VIDIOC_ENUM_FRAMESIZES这2个ioctl来获得这些细节：</p><ul><li>VIDIOC_ENUM_FMT：枚举格式</li><li>VIDIOC_ENUM_FRAMESIZES：枚举指定格式的帧大小(即分辨率)</li></ul><h3 id="3-2代码"><a href="#3-2代码" class="headerlink" title="3.2代码"></a>3.2代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span>   <span class="comment">/* for videodev2.h */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/videodev2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFFERS 32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 亮度控制线程的函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thread_brightness_control</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    <span class="comment">// 将参数转换为文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = (<span class="type">int</span>)args;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> brightness;</span><br><span class="line">    <span class="type">int</span> delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询亮度控制的属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_queryctrl</span> <span class="title">qctrl</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;qctrl, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_queryctrl));</span><br><span class="line">    qctrl.id = V4L2_CID_BRIGHTNESS;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ioctl(fd, VIDIOC_QUERYCTRL, &amp;qctrl)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can not query brightness\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印亮度的最小值和最大值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;brightness min = %d, max = %d\n&quot;</span>, qctrl.minimum, qctrl.maximum);</span><br><span class="line">    <span class="comment">// 计算亮度变化步长</span></span><br><span class="line">    delta = (qctrl.maximum - qctrl.minimum) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前亮度值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_control</span> <span class="title">ctl</span>;</span></span><br><span class="line">    ctl.id = V4L2_CID_BRIGHTNESS;</span><br><span class="line">    ioctl(fd, VIDIOC_G_CTRL, &amp;ctl);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;brightness = %d\n&quot;</span>, ctl.value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取用户输入</span></span><br><span class="line">        c = getchar();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;u&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 增加亮度值</span></span><br><span class="line">            ctl.value += delta;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;d&#x27;</span> || c == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 减小亮度值</span></span><br><span class="line">            ctl.value -= delta;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确保亮度值在有效范围内</span></span><br><span class="line">        <span class="keyword">if</span> (ctl.value &gt; qctrl.maximum)</span><br><span class="line">            ctl.value = qctrl.maximum;</span><br><span class="line">        <span class="keyword">if</span> (ctl.value &lt; qctrl.minimum)</span><br><span class="line">            ctl.value = qctrl.minimum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置新的亮度值</span></span><br><span class="line">        ioctl(fd, VIDIOC_S_CTRL, &amp;ctl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_fmtdesc</span> <span class="title">fmtdesc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_frmsizeenum</span> <span class="title">fsenum</span>;</span></span><br><span class="line">    <span class="type">int</span> fmt_index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> frame_index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">void</span> *bufs[MAX_BUFFERS];</span><br><span class="line">    <span class="type">int</span> buf_cnt;</span><br><span class="line">    <span class="type">int</span> type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">    <span class="type">char</span> filename[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> file_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> <span class="title">fmt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> != argc) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage:%s &lt;/dev/video0&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开视频设备</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can not open %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设备的能力信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_capability</span> <span class="title">cap</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;cap, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_capability));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ioctl(fd, VIDIOC_QUERYCAP, &amp;cap)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error opening device %s: video capture not supported.\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(cap.capabilities &amp; V4L2_CAP_STREAMING)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s does not support streaming i/o\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can not get capability\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举并打印支持的格式和帧大小</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;fmtdesc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_fmtdesc));</span><br><span class="line">        fmtdesc.index = fmt_index;</span><br><span class="line">        fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != ioctl(fd, VIDIOC_ENUM_FMT, &amp;fmtdesc))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        frame_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;fsenum, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_frmsizeenum));</span><br><span class="line">            fsenum.pixel_format = fmtdesc.pixelformat;</span><br><span class="line">            fsenum.index = frame_index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == ioctl(fd, VIDIOC_ENUM_FRAMESIZES, &amp;fsenum)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;format %s, %d, framesize %d:%d x %d\n&quot;</span>, fmtdesc.description, fmtdesc.pixelformat,</span><br><span class="line">                       fsenum.index, fsenum.discrete.width, fsenum.discrete.height);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            frame_index++;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt_index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置视频格式</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;fmt, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_format));</span><br><span class="line">    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    fmt.fmt.pix.width = <span class="number">1800</span>;</span><br><span class="line">    fmt.fmt.pix.height = <span class="number">1024</span>;</span><br><span class="line">    fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;</span><br><span class="line">    fmt.fmt.pix.field = V4L2_FIELD_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ioctl(fd, VIDIOC_S_FMT, &amp;fmt)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;set format ok: %d x %d\n&quot;</span>, fmt.fmt.pix.width, fmt.fmt.pix.height);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can not set pixelformat\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求内存映射缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> <span class="title">rb</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;rb, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_requestbuffers));</span><br><span class="line">    rb.count = MAX_BUFFERS;</span><br><span class="line">    rb.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    rb.memory = V4L2_MEMORY_MMAP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ioctl(fd, VIDIOC_REQBUFS, &amp;rb)) &#123;</span><br><span class="line">        buf_cnt = rb.count;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rb.count; i++) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">            <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_buffer));</span><br><span class="line">            buf.index = i;</span><br><span class="line">            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">            buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == ioctl(fd, VIDIOC_QUERYBUF, &amp;buf)) &#123;</span><br><span class="line">                <span class="comment">// 将缓冲区映射到用户空间</span></span><br><span class="line">                bufs[i] = mmap(<span class="number">0</span>, buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buf.m.offset);</span><br><span class="line">                <span class="keyword">if</span> (MAP_FAILED == bufs[i]) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;Unable to map buffer&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;can not query buffer\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;map %d buffers ok\n&quot;</span>, buf_cnt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can not request buffers\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲区放入队列</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buf_cnt; ++i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_buffer));</span><br><span class="line">        buf.index = i;</span><br><span class="line">        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">        buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != ioctl(fd, VIDIOC_QBUF, &amp;buf)) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Unable to queue buffer&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;queue buffers ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动视频流捕获</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ioctl(fd, VIDIOC_STREAMON, &amp;type)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Unable to start capture&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start capture ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建亮度控制线程</span></span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_brightness_control, (<span class="type">void</span> *)fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持续捕获视频流</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(fds, <span class="number">0</span>, <span class="keyword">sizeof</span>(fds));</span><br><span class="line">        fds[<span class="number">0</span>].fd = fd;</span><br><span class="line">        fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == poll(fds, <span class="number">1</span>, <span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">            <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> v4l2_buffer));</span><br><span class="line">            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">            buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != ioctl(fd, VIDIOC_DQBUF, &amp;buf)) &#123;</span><br><span class="line">                perror(<span class="string">&quot;Unable to dequeue buffer&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将捕获的帧保存为文件</span></span><br><span class="line">            <span class="built_in">sprintf</span>(filename, <span class="string">&quot;video_raw_data_%04d.jpg&quot;</span>, file_cnt++);</span><br><span class="line">            <span class="type">int</span> fd_file = open(filename, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">            <span class="keyword">if</span> (fd_file &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;can not create file : %s\n&quot;</span>, filename);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;capture to %s\n&quot;</span>, filename);</span><br><span class="line">            write(fd_file, bufs[buf.index], buf.bytesused);</span><br><span class="line">            close(fd_file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将缓冲区重新放入队列</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != ioctl(fd, VIDIOC_QBUF, &amp;buf)) &#123;</span><br><span class="line">                perror(<span class="string">&quot;Unable to queue buffer&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止视频流捕获</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ioctl(fd, VIDIOC_STREAMOFF, &amp;type)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Unable to stop capture&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stop capture ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭视频设备</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【LeetCode】H指数Day9</title>
    <link href="http://example.com/2024/03/28/LeetCode/%E3%80%90LeetCode%E3%80%91H%E6%8C%87%E6%95%B0Day9/"/>
    <id>http://example.com/2024/03/28/LeetCode/%E3%80%90LeetCode%E3%80%91H%E6%8C%87%E6%95%B0Day9/</id>
    <published>2024-03-28T12:05:03.000Z</published>
    <updated>2024-05-04T09:59:37.318Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】H指数Day9"><a href="#【LeetCode】H指数Day9" class="headerlink" title="【LeetCode】H指数Day9"></a>【LeetCode】H指数Day9</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数。计算并返回该研究者的 <strong><code>h</code> 指数</strong>。</p><p>根据维基百科上 <a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin">h 指数的定义</a>：<code>h</code> 代表“高引用次数” ，一名科研人员的 <code>h</code> <strong>指数</strong> 是指他（她）至少发表了 <code>h</code> 篇论文，并且 <strong>至少</strong> 有 <code>h</code> 篇论文被引用次数大于等于 <code>h</code> 。如果 <code>h</code> 有多种可能的值，<strong><code>h</code> 指数</strong> 是其中最大的那个。</p></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：citations = [3,0,6,1,5]</span><br><span class="line">输出：3 </span><br><span class="line">解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。</span><br><span class="line">     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的   h 指数是 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：citations = [1,3,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    与官方的方法一思路差不多。官方题解放下面</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算H指数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param citations 论文引用数组</span></span><br><span class="line"><span class="comment"> * @param citationsSize 数组大小</span></span><br><span class="line"><span class="comment"> * @return 返回H指数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>* citations, <span class="type">int</span> citationsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp; <span class="comment">// 临时变量用于交换元素</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用冒泡排序对引用数进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; citationsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j &lt; citationsSize - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(citations[j] &gt; citations[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                temp = citations[j];</span><br><span class="line">                citations[j] = citations[j+<span class="number">1</span>];</span><br><span class="line">                citations[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从前向后遍历排序后的数组，找到第一个满足条件的H指数即是最大的H指数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; citationsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(citationsSize-i &lt;= citations[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> citationsSize-i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果没有找到满足条件的H指数，返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="LeetCode官方题解"><a href="#LeetCode官方题解" class="headerlink" title="LeetCode官方题解"></a>LeetCode官方题解</h3><h4 id="方法三：二分搜索"><a href="#方法三：二分搜索" class="headerlink" title="方法三：二分搜索"></a>方法三：二分搜索</h4><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/h-index/solutions/869042/h-zhi-shu-by-leetcode-solution-fnhl/">https://leetcode.cn/problems/h-index/solutions/869042/h-zhi-shu-by-leetcode-solution-fnhl/</a><br>来源：力扣（LeetCode）</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    我们需要找到一个值 h，它是满足「有 h 篇论文的引用次数至少为 h」的最大值。小于等于 h 的所有值 x 都满足这个性质，而大于 h 的值都不满足这个性质。同时因为我们可以用较短时间（扫描一遍数组的时间复杂度为 O(n)，其中 nnn 为数组 citations 的长度）来判断 x 是否满足这个性质，所以这个问题可以用二分搜索来解决。</p><p>​    设查找范围的初始左边界 left 为 000，初始右边界 right为 n。每次在查找范围内取中点 mid，同时扫描整个数组，判断是否至少有 mid 个数大于 mid。如果有，说明要寻找的 h 在搜索区间的右边，反之则在左边。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>* citations, <span class="type">int</span> citationsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=citationsSize;</span><br><span class="line">    <span class="type">int</span> mid=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="comment">// +1 防止死循环</span></span><br><span class="line">        mid=(left+right+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;citationsSize;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(citations[i]&gt;=mid)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=mid)&#123;</span><br><span class="line">            <span class="comment">// 要找的答案在 [mid,right] 区间内</span></span><br><span class="line">            left=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 要找的答案在 [0,mid) 区间内</span></span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【LeetCode】跳跃游戏ⅡDay8</title>
    <link href="http://example.com/2024/03/26/LeetCode/%E3%80%90LeetCode%E3%80%91%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E2%85%A1Day8/"/>
    <id>http://example.com/2024/03/26/LeetCode/%E3%80%90LeetCode%E3%80%91%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E2%85%A1Day8/</id>
    <published>2024-03-26T10:30:03.000Z</published>
    <updated>2024-03-26T13:16:26.527Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】跳跃游戏ⅡDay8"><a href="#【LeetCode】跳跃游戏ⅡDay8" class="headerlink" title="【LeetCode】跳跃游戏ⅡDay8"></a>【LeetCode】跳跃游戏ⅡDay8</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code> </li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    与官方的方法二思路一样。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算跳跃游戏所需的最少步数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param nums 跳跃距离数组</span></span><br><span class="line"><span class="comment"> * @param numsSize 数组大小</span></span><br><span class="line"><span class="comment"> * @return 返回最少步数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxFoot = nums[<span class="number">0</span>]; <span class="comment">// 初始化当前能到达的最远位置</span></span><br><span class="line">    <span class="type">int</span> curFoot = <span class="number">0</span>; <span class="comment">// 初始化当前位置的跳跃距离</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>; <span class="comment">// 初始化步数为1，因为第一步已经跳过了</span></span><br><span class="line">    <span class="type">int</span> curP = <span class="number">0</span>; <span class="comment">// 初始化当前位置为数组的第一个位置</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> temp = curP; <span class="comment">// 临时变量用于记录当前可以跳到的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">1</span>)&#123; <span class="comment">// 如果数组大小为1，无需跳跃，直接返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(maxFoot &lt; numsSize - <span class="number">1</span>) <span class="comment">// 当还未到达终点时循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = curP; i &lt;= curP + nums[curP]; i++)&#123; <span class="comment">// 遍历当前位置能跳到的所有位置</span></span><br><span class="line">            curFoot = i + nums[i]; <span class="comment">// 计算当前位置的跳跃距离</span></span><br><span class="line">            <span class="keyword">if</span>(curFoot &gt; maxFoot)&#123; <span class="comment">// 如果当前位置的跳跃距离大于当前能到达的最远位置</span></span><br><span class="line">                maxFoot = curFoot; <span class="comment">// 更新最远位置</span></span><br><span class="line">                temp = i; <span class="comment">// 更新可以跳到的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++; <span class="comment">// 步数加1</span></span><br><span class="line">        curP = temp; <span class="comment">// 更新当前位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt; <span class="comment">// 返回最少步数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="LeetCode官方题解"><a href="#LeetCode官方题解" class="headerlink" title="LeetCode官方题解"></a>LeetCode官方题解</h3><h4 id="方法二：正向查找可到达的最大位置"><a href="#方法二：正向查找可到达的最大位置" class="headerlink" title="方法二：正向查找可到达的最大位置"></a>方法二：正向查找可到达的最大位置</h4><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/jump-game-ii/solutions/230241/tiao-yue-you-xi-ii-by-leetcode-solution/">https://leetcode.cn/problems/jump-game-ii/solutions/230241/tiao-yue-you-xi-ii-by-leetcode-solution/</a><br>来源：力扣（LeetCode）</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。</p><p>​    从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxPos = <span class="number">0</span>, n = nums.<span class="built_in">size</span>(), end = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxPos &gt;= i) &#123;</span><br><span class="line">                maxPos = <span class="built_in">max</span>(maxPos, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                    end = maxPos;</span><br><span class="line">                    ++step;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【LeetCode】跳跃游戏Day7</title>
    <link href="http://example.com/2024/03/22/LeetCode/%E3%80%90LeetCode%E3%80%91%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FDay7/"/>
    <id>http://example.com/2024/03/22/LeetCode/%E3%80%90LeetCode%E3%80%91%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FDay7/</id>
    <published>2024-03-22T11:07:03.000Z</published>
    <updated>2024-03-26T13:16:26.420Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】跳跃游戏Day7"><a href="#【LeetCode】跳跃游戏Day7" class="headerlink" title="【LeetCode】跳跃游戏Day7"></a>【LeetCode】跳跃游戏Day7</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    依次遍历数组记录跳跃最大距离，若最大距离大于数组长度则返回true，每次下一个元素时要判断跳跃最大距离是否大于元素下标。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxFoot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= maxFoot)&#123;</span><br><span class="line">            maxFoot = (nums[i] + i) &gt; maxFoot ? (nums[i] + i) : maxFoot;</span><br><span class="line">            <span class="keyword">if</span>(maxFoot &gt;= numsSize - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode官方题解"><a href="#LeetCode官方题解" class="headerlink" title="LeetCode官方题解"></a>LeetCode官方题解</h3><h4 id="方法一：贪心"><a href="#方法一：贪心" class="headerlink" title="方法一：贪心"></a>方法一：贪心</h4><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/jump-game/solutions/203549/tiao-yue-you-xi-by-leetcode-solution/">https://leetcode.cn/problems/jump-game/solutions/203549/tiao-yue-you-xi-by-leetcode-solution/</a><br>来源：力扣（LeetCode）</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> rightmost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= rightmost) &#123;</span><br><span class="line">                rightmost = <span class="built_in">max</span>(rightmost, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (rightmost &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【LeetCode】买卖股票的最佳时机Day6</title>
    <link href="http://example.com/2024/03/21/LeetCode/%E3%80%90LeetCode%E3%80%91%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BADay6/"/>
    <id>http://example.com/2024/03/21/LeetCode/%E3%80%90LeetCode%E3%80%91%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BADay6/</id>
    <published>2024-03-20T16:17:03.000Z</published>
    <updated>2024-03-21T09:07:18.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】买卖股票的最佳时机Day6"><a href="#【LeetCode】买卖股票的最佳时机Day6" class="headerlink" title="【LeetCode】买卖股票的最佳时机Day6"></a>【LeetCode】买卖股票的最佳时机Day6</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p></li></ul><h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    依次遍历数组相邻两个数先找到极小值，然后一直寻找极大值，计算其利润并比较大小。若找到新的极小值先与旧的极小值比较，若新极小值小于旧极小值，则将新极小值替代旧极小值并将极大值置0，否则不变，循环上述步骤。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算股票的最大利润</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param prices 股票价格数组</span></span><br><span class="line"><span class="comment"> * @param pricesSize 股票价格数组的大小</span></span><br><span class="line"><span class="comment"> * @return 返回最大利润</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> minPrices = prices[<span class="number">0</span>]; <span class="comment">// 初始化最小价格为第一天的价格</span></span><br><span class="line">    <span class="type">int</span> maxPrices = <span class="number">0</span>; <span class="comment">// 初始化最大价格为0</span></span><br><span class="line">    <span class="type">int</span> maxProfit = <span class="number">0</span>; <span class="comment">// 初始化最大利润为0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left;</span><br><span class="line">    <span class="type">int</span> right;</span><br><span class="line">    <span class="type">int</span> g;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pricesSize == <span class="number">1</span>)&#123; <span class="comment">// 如果只有一天的价格，无法交易，直接返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        left = <span class="number">0</span>; <span class="comment">// 设置左指针为数组的第一个元素</span></span><br><span class="line">        right = <span class="number">1</span>; <span class="comment">// 设置右指针为数组的第二个元素</span></span><br><span class="line">        g = prices[left]&gt;prices[right] ? <span class="number">0</span> : <span class="number">1</span>; <span class="comment">// 判断价格趋势，g为0表示递减，g为1表示递增</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历价格数组</span></span><br><span class="line">    <span class="keyword">while</span>(right&lt;pricesSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果价格递减并且g为1，表示进入递减阶段</span></span><br><span class="line">        <span class="keyword">if</span>(prices[left] &gt; prices[right] &amp;&amp; g)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[left] &gt; maxPrices)&#123; <span class="comment">// 更新最大价格</span></span><br><span class="line">                maxPrices = prices[left];</span><br><span class="line">                <span class="keyword">if</span>(maxProfit &lt; maxPrices - minPrices)&#123; <span class="comment">// 更新最大利润</span></span><br><span class="line">                    maxProfit = maxPrices - minPrices;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            g = <span class="number">0</span>; <span class="comment">// 标记为递减</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果价格递增并且g为0，表示进入递增阶段</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(prices[left] &lt; prices[right] &amp;&amp; !g)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[left] &lt; minPrices)&#123; <span class="comment">// 更新最小价格</span></span><br><span class="line">                minPrices = prices[left];</span><br><span class="line">                maxPrices = <span class="number">0</span>; <span class="comment">// 重置最大价格</span></span><br><span class="line">            &#125;</span><br><span class="line">            g = <span class="number">1</span>; <span class="comment">// 标记为递增</span></span><br><span class="line">        &#125;</span><br><span class="line">        left++; <span class="comment">// 移动左指针</span></span><br><span class="line">        right++; <span class="comment">// 移动右指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理最后一个价格</span></span><br><span class="line">    <span class="keyword">if</span>(!g &amp;&amp; prices[pricesSize<span class="number">-1</span>]&lt;minPrices)&#123;</span><br><span class="line">        minPrices = prices[pricesSize<span class="number">-1</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(g &amp;&amp; prices[pricesSize<span class="number">-1</span>]&gt;maxPrices)&#123;</span><br><span class="line">        maxPrices = prices[pricesSize<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(maxProfit &lt; maxPrices - minPrices)&#123;</span><br><span class="line">             maxProfit = maxPrices - minPrices;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果最大利润小于等于0，则返回0</span></span><br><span class="line">    <span class="keyword">if</span>(maxProfit &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit; <span class="comment">// 返回最大利润</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode官方题解"><a href="#LeetCode官方题解" class="headerlink" title="LeetCode官方题解"></a>LeetCode官方题解</h3><h4 id="方法一：一次遍历"><a href="#方法一：一次遍历" class="headerlink" title="方法一：一次遍历"></a>方法一：一次遍历</h4><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/136684/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/136684/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/</a><br>来源：力扣（LeetCode）</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">        <span class="type">int</span> minprice = inf, maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price: prices) &#123;</span><br><span class="line">            maxprofit = <span class="built_in">max</span>(maxprofit, price - minprice);</span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【LeetCode】多数元素Day5</title>
    <link href="http://example.com/2024/03/13/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0Day5/"/>
    <id>http://example.com/2024/03/13/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0Day5/</id>
    <published>2024-03-12T16:08:14.000Z</published>
    <updated>2024-03-13T00:47:03.144Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】多数元素Day5"><a href="#【LeetCode】多数元素Day5" class="headerlink" title="【LeetCode】多数元素Day5"></a>【LeetCode】多数元素Day5</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p></li></ul><h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    依次遍历数组中的每个数并统计出现的次数，并针对特殊情况作出优化。</p><p>​    （受限于知识储备，之前题目的影响，本题没想出很好的方法，自己的方法在特殊情况的时候应该还会超时。）</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    使用双指针遍历数组元素，并统计出现次数，直到出现次数大于<code>⌊ n/2 ⌋</code>，返回当前统计的元素 ；或出现次数加上剩余元素小于<code>⌊ n/2 ⌋</code> ，进行下一个元素的统计，直到有元素出现次数大于<code>⌊ n/2 ⌋</code>。具体方法与前面删除重复项相似。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="type">int</span> fast, slow;</span><br><span class="line"><span class="type">int</span> mark = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fast = <span class="number">1</span>;</span><br><span class="line">slow = <span class="number">0</span>;</span><br><span class="line">res = numsSize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(mark &lt;= (numsSize/<span class="number">2</span>))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[slow] == nums[fast])</span><br><span class="line">        &#123;</span><br><span class="line">            mark++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast++; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fast--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res--;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mark &gt; (numsSize/<span class="number">2</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[slow];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((mark+res) &lt;= (numsSize/<span class="number">2</span>) &amp;&amp; (i == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            slow = numsSize - slow;</span><br><span class="line">            fast = slow - <span class="number">1</span>;</span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            res = fast;</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((mark+res) &lt;= (numsSize/<span class="number">2</span>) &amp;&amp; (i == <span class="number">1</span>))&#123;</span><br><span class="line">            slow = numsSize - slow;</span><br><span class="line">            fast = slow + <span class="number">1</span>;</span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            res = numsSize - fast;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[slow+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode官方题解"><a href="#LeetCode官方题解" class="headerlink" title="LeetCode官方题解"></a>LeetCode官方题解</h3><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/">https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/</a><br>来源：力扣（LeetCode）</p><h4 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h4><h5 id="思路及算法"><a href="#思路及算法" class="headerlink" title="思路及算法"></a>思路及算法</h5><p>​    我们知道出现次数最多的元素大于 n/2 次，所以可以用哈希表来快速统计每个元素出现的次数。</p><p>​    我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。</p><p>​    我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，返回值最大的键。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">        <span class="type">int</span> majority = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            ++counts[num];</span><br><span class="line">            <span class="keyword">if</span> (counts[num] &gt; cnt) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                cnt = counts[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h4><p>思路及算法</p><p>​    如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 n/2 的元素（下标从 0 开始）一定是众数。</p><p>​    对于这种算法，我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 nnn 为奇数的情况，第二个例子是 n 为偶数的情况。</p><p>​    对于每种情况，数组上面的线表示如果众数是数组中的最小值时覆盖的下标，数组下面的线表示如果众数是数组中的最大值时覆盖的下标。对于其他的情况，这条线会在这两种极端情况的中间。对于这两种极端情况，它们会在下标为 n/2 的地方有重叠。因此，无论众数是多少，返回 n/2 下标对应的值都是正确的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法三：Boyer-Moore-投票算法"><a href="#方法三：Boyer-Moore-投票算法" class="headerlink" title="方法三：Boyer-Moore 投票算法"></a>方法三：Boyer-Moore 投票算法</h4><p>思路</p><p>​    如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</p><p>​    首先给出 Boyer-Moore 算法的详细步骤：</p><p>​    我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</p><p>​    我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：</p><p>​    如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</p><p>​    如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</p><p>​    在遍历完成后，candidate 即为整个数组的众数。</p><p>​    我们举一个具体的例子，例如下面的这个数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span><br></pre></td></tr></table></figure><p>​    在遍历到数组中的第一个元素以及每个在 | 之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。</p><p>​    Boyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考：</p><p>​    首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。</p><p>​    那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span><br></pre></td></tr></table></figure><p>​    作为例子，首先写下它在每一步遍历时 candidate 和 count 的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span><br><span class="line">candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7</span><br><span class="line">count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4</span><br></pre></td></tr></table></figure><p>​    我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span><br><span class="line">value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4</span><br></pre></td></tr></table></figure><p>​    有没有发现什么？我们将 count 和 value 放在一起：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</span><br><span class="line">count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4</span><br><span class="line">value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4</span><br></pre></td></tr></table></figure><p>​    发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！</p><p>​    为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。</p><p>​    这样以来，由于：</p><p>​    我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此；</p><p>​    由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数；</p><p>​    在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数 maj。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> candidate = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == candidate)</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (--count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    学到了哈希表的使用和Boyer-Moore投票算法。方法二的排序思路也想到了，但差一点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【LeetCode】删除有序数组中的重复项ⅡDay4</title>
    <link href="http://example.com/2024/03/08/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E2%85%A1Day4/"/>
    <id>http://example.com/2024/03/08/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E2%85%A1Day4/</id>
    <published>2024-03-07T16:16:14.000Z</published>
    <updated>2024-03-08T08:17:03.832Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】删除有序数组中的重复项ⅡDay4"><a href="#【LeetCode】删除有序数组中的重复项ⅡDay4" class="headerlink" title="【LeetCode】删除有序数组中的重复项ⅡDay4"></a>【LeetCode】删除有序数组中的重复项ⅡDay4</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><p>给你一个有序数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p></li></ul><h2 id="1-三指针"><a href="#1-三指针" class="headerlink" title="1. 三指针"></a>1. 三指针</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    第一个指针p用来指向存放元素位置并计算唯一元素的数量k。剩下两个指针（左右指针）用来判断重复出现的元素，增加了一个标记位mark，记录元素出现次数。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    若左指针指向的元素等于右指针，使右指针右移一位，mark加一，直到左指针不等于右指针，将左指针的元素赋给第一个指针p指向的位置，mark置一，第一个指针p右移一位，右指针右移一位，左指针移到右指针左一位，每次循环都要判断右指针是否最后一位，若是，则直接将右指针指向的元素赋给第一个指针p指向的位置。（每次赋值前需判断mark是否大于等于2，若是，则需将nums[p]和nums[p+1]都赋值）</p><p>​    当右指针大于等于数组大小的时候，右指针遍历完数组中的所有元素。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] != nums[right])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mark &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[p++] = nums[left];</span><br><span class="line">                nums[p++] = nums[left];   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[p++] = nums[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left = right;</span><br><span class="line">            right++;</span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] == nums[right])&#123;</span><br><span class="line">            right++;</span><br><span class="line">            mark++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == numsSize)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mark &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[p++] = nums[left];</span><br><span class="line">                nums[p] = nums[left];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[p] = nums[numsSize<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode官方题解"><a href="#LeetCode官方题解" class="headerlink" title="LeetCode官方题解"></a>LeetCode官方题解</h3><h4 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h4><h5 id="思路及解法"><a href="#思路及解法" class="headerlink" title="思路及解法"></a>思路及解法</h5><p>​    因为给定数组是有序的，所以相同元素必然连续。我们可以使用双指针解决本题，遍历数组检查每一个元素是否应该被保留，如果应该被保留，就将其移动到指定位置。具体地，我们定义两个指针 <em>slow</em> 和 fast 分别为慢指针和快指针，其中慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度，即 <em>nums[fast]</em> 表示待检查的第一个元素，<em>nums[slow−1]</em>为上一个应该被保留的元素所移动到的指定位置。</p><p>​    因为本题要求相同元素最多出现两次而非一次，所以我们需要检查上上个应该被保留的元素 <em>nums[slow−2]</em> 是否和当前待检查元素 <em>nums[fast]</em> 相同。当且仅当 <em>nums[slow−2]=nums[fast]</em> 时，当前待检查元素 <em>nums[fast]</em>不应该被保留（因为此时必然有<em>nums[slow−2]=nums[slow−1]=nums[fast]</em>）。最后，slow 即为处理好的数组的长度。</p><p>​    特别地，数组的前两个数必然可以被保留，因此对于长度不超过 2 的数组，我们无需进行任何处理，对于长度超过 2 的数组，我们直接将双指针的初始值设为 2 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> slow = <span class="number">2</span>, fast = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; numsSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[slow - <span class="number">2</span>] != nums[fast]) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            ++slow;</span><br><span class="line">        &#125;</span><br><span class="line">        ++fast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>​    还是跟昨天一样的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【LeetCode】删除有序数组中的重复项Day3</title>
    <link href="http://example.com/2024/03/08/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9Day3/"/>
    <id>http://example.com/2024/03/08/LeetCode/%E3%80%90LeetCode%E3%80%91%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9Day3/</id>
    <published>2024-03-07T16:09:55.000Z</published>
    <updated>2024-03-08T08:15:07.154Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】删除有序数组中的重复项Day3"><a href="#【LeetCode】删除有序数组中的重复项Day3" class="headerlink" title="【LeetCode】删除有序数组中的重复项Day3"></a>【LeetCode】删除有序数组中的重复项Day3</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你<strong><a href="http://baike.baidu.com/item/原地算法"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><h2 id="1-三指针"><a href="#1-三指针" class="headerlink" title="1. 三指针"></a>1. 三指针</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    第一个指针用来指向存放元素位置并计算唯一元素的数量k。剩下两个指针（左右指针）用来判断重复出现的元素。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    若左指针指向的元素等于右指针，使右指针右移一位，直到左指针不等于右指针，将左指针的元素赋给第一个指针指向的位置，第一个指针右移一位，右指针右移一位，左指针移到右指针左一位，每次循环都要判断右指针是否最后一位，若是，则直接将右指针指向的元素赋给第一个指针指向的位置。</p><p>​    当右指针大于等于数组大小的时候，右指针遍历完数组中的所有元素。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] != nums[right])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[p] = nums[left];</span><br><span class="line">            p++;</span><br><span class="line">            left = right;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] == nums[right])&#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == numsSize)&#123;</span><br><span class="line">            nums[p] = nums[numsSize<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>方法一：双指针</p><p>这道题目的要求是：对给定的有序数组 <em>nums</em> 删除重复元素，在删除重复元素之后，每个元素只出现一次，并返回新的长度，上述操作必须通过原地修改数组的方法，使用 <em>O(1)</em> 的空间复杂度完成。</p><p>由于给定的数组 <em>nums</em> 是有序的，因此对于任意 <em>i&lt;j</em>，如果 <em>nums[i]=nums[j]</em>，则对任意 <em>i≤k≤j</em>，必有 <em>nums[i]=nums[k]=nums[j]</em>，即相等的元素在数组中的下标一定是连续的。利用数组有序的特点，可以通过双指针的方法删除重复元素。</p><p>如果数组 <em>nums</em> 的长度为 0，则数组不包含任何元素，因此返回 0。</p><p>当数组 <em>nums</em> 的长度大于 0 时，数组中至少包含一个元素，在删除重复元素之后也至少剩下一个元素，因此 <em>nums[0]</em> 保持原状即可，从下标 111 开始删除重复元素。</p><p>定义两个指针 <em>fast</em> 和 <em>slow</em> 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 <em>1</em>。</p><p>假设数组 <em>nums</em> 的长度为 <em>n</em>。将快指针 <em>fast</em> 依次遍历从 <em>1</em> 到 <em>n−1</em> 的每个位置，对于每个位置，如果 <em>nums[fast]≠nums[fast−1]</em>，说明 <em>nums[fast]</em> 和之前的元素都不同，因此将 <em>nums[fast]</em> 的值复制到 <em>nums[slow]</em>，然后将 <em>slow</em>的值加 <em>1</em>，即指向下一个位置。</p><p>遍历结束之后，从 <em>nums[0]</em> 到 <em>nums[slow−1]</em> 的每个元素都不相同且包含原数组中的每个不同的元素，因此新的长度即为 <em>slow</em>，返回 <em>slow</em> 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fast = <span class="number">1</span>, slow = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; numsSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            ++slow;</span><br><span class="line">        &#125;</span><br><span class="line">        ++fast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    自己的方法有点多此一举了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【LeetCode】移除元素Day2</title>
    <link href="http://example.com/2024/03/07/LeetCode/%E3%80%90LeetCode%E3%80%91%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0Day2/"/>
    <id>http://example.com/2024/03/07/LeetCode/%E3%80%90LeetCode%E3%80%91%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0Day2/</id>
    <published>2024-03-06T16:08:23.000Z</published>
    <updated>2024-03-08T02:03:24.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【LeetCode】移除元素Day2"><a href="#【LeetCode】移除元素Day2" class="headerlink" title="【LeetCode】移除元素Day2"></a>【LeetCode】移除元素Day2</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/原地算法">原地 </a>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素</p><h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​    因为元素顺序可以改变并且不需要考虑数组中超出新长度后面的元素，所以可以从数组首尾向中间遍历。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>​    如果左指针指向的元素等于val，将右指针指向的元素复制到左指针的位置，然后右指针左移一位。若复制过来的元素也等于val，继续把右指针指向的元素复制过来，直到左指针指向的元素不等于val。</p><p>​    当左指针和右指针重合的时候，左右指针遍历完数组中所有元素。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] == val) &#123;</span><br><span class="line">            nums[left] = nums[right - <span class="number">1</span>];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【嵌入式】第一个驱动</title>
    <link href="http://example.com/2023/10/15/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8/"/>
    <id>http://example.com/2023/10/15/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8/</id>
    <published>2023-10-14T16:00:00.000Z</published>
    <updated>2024-01-25T11:11:54.035Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】第一个驱动"><a href="#【嵌入式】第一个驱动" class="headerlink" title="【嵌入式】第一个驱动"></a>【嵌入式】第一个驱动</h1><h2 id="编写驱动程序步骤"><a href="#编写驱动程序步骤" class="headerlink" title="编写驱动程序步骤"></a>编写驱动程序步骤</h2><ol><li>确定主设备号，也可以让内核分配</li><li>定义驱动程序的file_operations结构体</li><li>实现驱动程序对应的drv_open/drv_read/drv_write等函数，填入file_operations结构体</li><li>创建入口函数来安装驱动程序，把file_operations结构体告诉内核，调用<code>register_chrdev</code></li><li>创建出口函数来卸载驱动程序，出口函数调用<code>unregister_chrdev</code></li><li>其他完善，入口函数：提供设备信息<code>class_create</code>，自动创建设备节点<code>device_create</code>；出口函数：<code>class_destroy</code>，<code>device_destroy</code></li></ol><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><div class="tip bell"><p>代码可参考内核源码中driver/char的程序，包含头文件，写框架，传输数据</p></div><ul><li><p>驱动中实现open，read，write，releas，APP调用这些函数时，都打印内核信息</p></li><li><p>APP调用write函数时，传入的数据保存在驱动中</p></li><li><p>APP调用read函数时，把驱动中保存的数据返回给APP</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 确定主设备号 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;<span class="comment">//令major=0，让内核给驱动设置设备号</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kernel_buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b)(a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动对应的open/read/write等函数，填入file_operations结构体 */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<span class="comment">//打印内核信息，下同</span></span><br><span class="line">err = copy_to_user(buf, kernel_buf, MIN(size, <span class="number">1024</span>));<span class="comment">//copy_to_user(void __user *to, const void *from, unsigned long n)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello_drv_read error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> MIN(size, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">err = copy_from_user(kernel_buf, buf, MIN(size, <span class="number">1024</span>));<span class="comment">//copy_from_user(void *to, const void __user *from, unsigned long n)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == err)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello_drv_write error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> MIN(size, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义自己的file_operations结构体 */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.open= hello_drv_open,</span><br><span class="line">.read= hello_drv_read,</span><br><span class="line">.write      = hello_drv_write,</span><br><span class="line">.release    = hello_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把file_operations结构体告诉内核：注册驱动程序 */</span></span><br><span class="line"><span class="comment">/* 注册驱动程序,入口函数：安装驱动程序时，就会去调用这个入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv);  <span class="comment">/* /dev/hello */</span></span><br><span class="line"></span><br><span class="line">hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br><span class="line">err = PTR_ERR(hello_class);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(hello_class)) &#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">/* /dev/hello */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出口函数：卸载驱动程序时，就会去调用这个出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">device_destroy(hello_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">class_destroy(hello_class);</span><br><span class="line">unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他完善：提供设备信息，自动创建设备节点 */</span></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【嵌入式】文件IO基础</title>
    <link href="http://example.com/2023/08/13/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%96%87%E4%BB%B6IO/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E6%96%87%E4%BB%B6IO/"/>
    <id>http://example.com/2023/08/13/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E6%96%87%E4%BB%B6IO/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E6%96%87%E4%BB%B6IO/</id>
    <published>2023-08-12T16:00:00.000Z</published>
    <updated>2024-01-25T11:40:25.868Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】文件IO基础"><a href="#【嵌入式】文件IO基础" class="headerlink" title="【嵌入式】文件IO基础"></a>【嵌入式】文件IO基础</h1><p>​    在Linux系统中，一切都是文件：普通文件、驱动程序、网络通信等等。所有的操作，都是通过文件IO来操作的。</p><pre><code>## 通用的IO模型：创建/打开/读写/定位/关闭</code></pre><ol><li><p>创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>参数mode指定新建文件的存取权限，它同umask一起决定文件的最终权限(mode&amp;umask)，其中，umask代表了文件在创建时需要去掉的一些存取权限。umask可通过系统调用umask()来改变：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">umask</span><span class="params">(<span class="type">int</span> newmask)</span>;</span><br></pre></td></tr></table></figure><p>该调用将umask设置为newmask，然后返回旧的umask，它只影响读、写和执行权限。</p></li><li><p>打开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>open()函数有两种形式，其中pathname是我们要打开的文件名(包含路径名称，缺省是认为在当前路径下面)，flags可以是下表的一个或几个值的组合。</p><p>|   标志    |                        含义                         |<br>| :———-: | :————————————————————————-: |<br>| O_RDONLY  |                以只读的方式打开文件                 |<br>| O_WRONLY  |                以只写的方式打开文件                 |<br>|  O_RDWR   |                以读写的方式打开文件                 |<br>| O_APPEND  |                以追加的方式打开文件                 |<br>|  O_CREAT  |                    创建一个文件                     |<br>|  O_EXEC   | 如果使用了O_CREAT而且文件已经存在，就会发生一个错误 |<br>| O_NOBLOCK |             以非阻塞的方式打开一个文件              |<br>|  O_TRUNC  |         如果文件已经存在，则删除文件的内容          |</p><p>O_RDONLY、O_WRONLY、O_RDWR三个标志只能使用任意一个。</p><p>如果使用了O_CREAT标志，则需要指定mode标志，以表示文件的访问权限。</p></li><li><p>读写</p></li><li><p>定位</p></li><li><p>关闭</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【嵌入式】开发板挂载Ubuntu的NFS目录</title>
    <link href="http://example.com/2023/06/03/%E5%B5%8C%E5%85%A5%E5%BC%8F/NFS/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E5%BC%80%E5%8F%91%E6%9D%BF%E6%8C%82%E8%BD%BDUbuntu%E7%9A%84NFS%E7%9B%AE%E5%BD%95/"/>
    <id>http://example.com/2023/06/03/%E5%B5%8C%E5%85%A5%E5%BC%8F/NFS/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E5%BC%80%E5%8F%91%E6%9D%BF%E6%8C%82%E8%BD%BDUbuntu%E7%9A%84NFS%E7%9B%AE%E5%BD%95/</id>
    <published>2023-06-02T16:00:00.000Z</published>
    <updated>2024-01-25T11:42:14.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】开发板挂载Ubuntu的NFS目录"><a href="#【嵌入式】开发板挂载Ubuntu的NFS目录" class="headerlink" title="【嵌入式】开发板挂载Ubuntu的NFS目录"></a>【嵌入式】开发板挂载Ubuntu的NFS目录</h1><div class="tip "><p>NFS协议</p></div><p>​    NFS实现了一个跨越网络的文件访问功能，如下图可以简要说明其原理。其整个架构为Client-Server架构，客户端和服务端通过RPC协议进行通信，RPC协议可以简单的理解为一个基于TCP的应用层协议，它简化命令和数据的传输。NFS最大的特点是将服务端的文件系统目录树映射到客户端，而在客户端访问该目录树与访问本地文件系统没有任何差别，客户端并不知道这个文件系统目录树是本地的还是远在另外一台服务器。</p><div class="tip "><p>挂载ubuntu的nfs目录的意义</p></div><p>​    有些时候需要多次调试开发板文件系统内的某个应用程序，这就需要多次进行编译拷贝等操作，所以在前期进行调试时可以直接让开发板使用ubuntu的nfs目录下文件系统来进行远程调试，用以提高调试效率，加快研发速度。</p><h2 id="使用网络文件系统（NFS）的前提"><a href="#使用网络文件系统（NFS）的前提" class="headerlink" title="使用网络文件系统（NFS）的前提"></a>使用网络文件系统（NFS）的前提</h2><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><div class="tip info"><p>cat /etc/exports</p></div><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202401182049704.png" alt="fig1"></p><p>/home/book/ 目录可给任何用户使用。</p><h3 id="启动NFS"><a href="#启动NFS" class="headerlink" title="启动NFS"></a>启动NFS</h3><p>查看NFS是否启动</p><div class="tip info"><p>ps -A | grep nfs</p></div><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202401182049491.png" alt="fig2"></p><p>如上图即可。</p><div class="tip bell"><p>权限和NFS的配置，在环境配置中执行的脚本已经自动打开</p></div><h3 id="挂载（mount）"><a href="#挂载（mount）" class="headerlink" title="挂载（mount）"></a>挂载（mount）</h3><h4 id="开发板与ubuntu是否互ping成功"><a href="#开发板与ubuntu是否互ping成功" class="headerlink" title="开发板与ubuntu是否互ping成功"></a>开发板与ubuntu是否互ping成功</h4><div class="tip info"><p>查看ip：ifconfig</p></div><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202401182050473.png" alt="fig3"></p><p><img src="https://gitee.com/tayccc/picgo/raw/master/img/202401182049833.png" alt="fig4"></p><p>查看完ip后，两机互ping。</p><div class="tip key"><p>开发板挂载：mount -t nfs -o nolock,vers=3 192.168.5.11:/home/book/nfs_rootfs /mnt</p></div><p>挂载完成后，可在nfs_rootfs文件夹中添加文件测试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【嵌入式】Makefile 基础</title>
    <link href="http://example.com/2023/05/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/Makefile/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91Makefile/"/>
    <id>http://example.com/2023/05/28/%E5%B5%8C%E5%85%A5%E5%BC%8F/Makefile/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91Makefile/</id>
    <published>2023-05-27T16:00:00.000Z</published>
    <updated>2024-01-25T11:28:04.642Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】Makefile-基础"><a href="#【嵌入式】Makefile-基础" class="headerlink" title="【嵌入式】Makefile 基础"></a>【嵌入式】Makefile 基础</h1><h2 id="1-Makefile-是什么"><a href="#1-Makefile-是什么" class="headerlink" title="1. Makefile 是什么"></a>1. Makefile 是什么</h2><p>​    一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile就像一个Shell脚本一样，也可以执行操作系统的命令。</p><div class="tip sync"><p>Makefile 可以大大提高编译效率，在修改源文件或头文件时，只需要重新编译涉及到的文件，</p></div><h2 id="2-Makefile-规则"><a href="#2-Makefile-规则" class="headerlink" title="2. Makefile 规则"></a>2. Makefile 规则</h2><p>​    一个Makefile文件包含一系列的规则，其样式如下：</p><div class="tip info"><p>目标(target)…: 依赖(dependency)…</p><p><tab> 命令(command)</p></div><p>​    如果“依赖文件”比“目标文件”更加新，就执行命令来重新生成“目标文件”。</p><p>​    命令被执行的两个条件：1. “依赖文件”比“目标文件”新；2. 目标文件未生成。</p><h2 id="3-Makefile-语法"><a href="#3-Makefile-语法" class="headerlink" title="3. Makefile 语法"></a>3. Makefile 语法</h2><ul><li><p>make命令</p><p>​        执行make命令时，会在当前目录下查找“Makefile”文件，并根据它的指示去执行操作，生成第一个目标。</p><p>​        使用“-f”选项指定文件，不再使用名为“Makefile”的文件，比如：</p><div class="tip info"><p>make    -f    Makefile.build</p></div><p>​        使用“-C”选项指定目录，切换到其他目录里去，比如：</p><div class="tip info"><p>make    -C    a/    -f    Makefile.build</p></div><p>​        指定目标，不再默认生成第一个目标：</p><div class="tip info"><p>make    -C    a/    -f    Makefile.build    other_target</p></div></li><li><p>变量</p><p>变量定义：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A =  xxx// 延时变量</span><br><span class="line"></span><br><span class="line">B ?= xxx// 延时变量，只有第一次定义时赋值才成功</span><br><span class="line"></span><br><span class="line">C :=  xxx// 立即变量</span><br><span class="line"></span><br><span class="line">D += xxx// D之前是什么变量就是什么变量</span><br></pre></td></tr></table></figure><p>​        编译程序时，切换到其他目录执行Makefile，如果想让某个变量的值在所有目录都可见，可以使用export，如：</p><div class="tip info"><p>CC = $(CROSS_COMPILE)gcc </p><p>  export CC = $(CROSS_COMPILE)gcc </p></div></li><li><p>shell命令</p><div class="tip info"><p>TOPDIR := $(shell pwd)</p></div><p>​        TOPDIR为立即变量，值为shell命令pwd的结果。</p></li><li><p>第一个目标</p><p>​        执行make命令若不指定目标，默认生成第一个目标。</p><p>​        所以第一个目标，位置很重要。有时候不太方便把第一个目标完整地放<br>在文件前面，这时可以在文件的前面直接放置目标，在后面再完善它的依赖与<br>命令。比如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">First_target: // 这句话放在前面</span></span><br><span class="line">...... // 其他代码，比如 <span class="keyword">include</span> 其他文件得到后面的 xxx 变量</span><br><span class="line">First_target : <span class="variable">$(xxx)</span> <span class="variable">$(yyy)</span> // 在文件的后面再来完善</span><br><span class="line">command</span><br></pre></td></tr></table></figure></li><li><p>假想目标</p><p>​        假如Makefile中有这样的目标：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">rm -f <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>​        如果当前目录下恰好有名为“clean”的文件，那么执行“make clean”时它就不会执行删除命令。这时可以将clean设置为假想目标，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">rm -f <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>常用函数</li></ul><ol><li><p>$(foreach var,list,text)</p><p>简单地说，就是 for each var in list, change it to text。对 list 中的每一个元素，取出来赋给 var，然后把 var 改为 text 所描述的形式。</p><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objs := a.o b.o</span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f, <span class="variable">$(objs)</span>, .<span class="variable">$(f)</span>.d)</span> // 最终 dep_files := .a.o.d .b.o.d</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>$(wildcard pattern)</p><p>pattern 所列出的文件是否存在，把存在的文件都列出来。<br>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src_files := $( wildcard *.c) // 最终 src_files 中列出了当前目录下的所有.c 文件</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>$(filter pattern…,text)</p><p>把 text 中符合 pattern 格式的内容，filter(过滤)出来、留下来。</p><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-y := a.o b.o c/ d/</span><br><span class="line">DIR := <span class="variable">$(<span class="built_in">filter</span> %/, $(obj-y)</span>) //结果为：c/ d/</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>$(filter-out pattern…,text)</p><p>把 text 中符合 pattern 格式的内容，filter-out(过滤)出来、扔掉。</p><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-y := a.o b.o c/ d/</span><br><span class="line">DIR := <span class="variable">$(<span class="built_in">filter</span>-out %/, $(obj-y)</span>) //结果为：a.o b.o</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>$(patsubst pattern,replacement,text)</p><p>寻找”text”中符合格式”pattern”的字，用”replacement”替换它们。</p><p>“pattern”和”replacement”中可以使用通配符。</p><p>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subdir-y := c/ d/</span><br><span class="line">subdir-y := <span class="variable">$(<span class="built_in">patsubst</span> %/, %, $(subdir-y)</span>) // 结果为：c d</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【嵌入式】虚拟机Ubuntu环境配置</title>
    <link href="http://example.com/2023/05/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2023/05/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E3%80%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E3%80%91%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2023-05-22T11:42:13.000Z</published>
    <updated>2024-01-25T11:44:25.272Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【嵌入式】虚拟机Ubuntu环境配置"><a href="#【嵌入式】虚拟机Ubuntu环境配置" class="headerlink" title="【嵌入式】虚拟机Ubuntu环境配置"></a>【嵌入式】虚拟机Ubuntu环境配置</h1><h2 id="一键配置开发环境（此脚本只支持Ubuntu-16-04-Ubuntu-18-04）"><a href="#一键配置开发环境（此脚本只支持Ubuntu-16-04-Ubuntu-18-04）" class="headerlink" title="一键配置开发环境（此脚本只支持Ubuntu-16.04/Ubuntu-18.04）"></a>一键配置开发环境（此脚本只支持Ubuntu-16.04/Ubuntu-18.04）</h2><h3 id="在终端输入下面命令"><a href="#在终端输入下面命令" class="headerlink" title="在终端输入下面命令"></a>在终端输入下面命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://e.coding.net/weidongshan/DevelopmentEnvConf.git</span><br><span class="line"></span><br><span class="line">cd DevelopmentEnvConf</span><br><span class="line"></span><br><span class="line">sudo ./Configuring_ubuntu.sh</span><br></pre></td></tr></table></figure><h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><div class="tip error"><p>E: Problem executing scripts APT::Update::Post-Invoke-Success ‘if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli; then appstreamcli refresh &gt; /dev/null; fi’<br>E: Sub-process returned an error code</p></div><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><div class="tip success"><p>sudo apt upgrade</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
